# Tolan çº§åˆ«è®°å¿†ç³»ç»Ÿå‡çº§æ–¹æ¡ˆ

> æ–‡æ¡£ç‰ˆæœ¬: 1.0
> åˆ›å»ºæ—¥æœŸ: 2026-01-27
> çŠ¶æ€: å¾…å®ç°

---

## ç›®å½•

1. [æ¦‚è¿°](#1-æ¦‚è¿°)
2. [åŠŸèƒ½è¯¦è§£ï¼ˆé€šä¿—ç‰ˆï¼‰](#2-åŠŸèƒ½è¯¦è§£é€šä¿—ç‰ˆ)
3. [ç³»ç»Ÿæ¶æ„](#3-ç³»ç»Ÿæ¶æ„)
4. [æ•°æ®åº“è®¾è®¡](#4-æ•°æ®åº“è®¾è®¡)
5. [Edge Function å®ç°](#5-edge-function-å®ç°)
6. [æ€§èƒ½ä¼˜åŒ–](#6-æ€§èƒ½ä¼˜åŒ–)
7. [éƒ¨ç½²é…ç½®](#7-éƒ¨ç½²é…ç½®)
8. [éªŒè¯è®¡åˆ’](#8-éªŒè¯è®¡åˆ’)
9. [å›æ»šç­–ç•¥](#9-å›æ»šç­–ç•¥)
10. [é™„å½•ï¼šå®Œæ•´ä»£ç ](#10-é™„å½•å®Œæ•´ä»£ç )

---

## 1. æ¦‚è¿°

### 1.1 é¡¹ç›®èƒŒæ™¯

å½“å‰è®°å¿†ç³»ç»Ÿä½¿ç”¨ç®€å•çš„æ–‡æœ¬æœç´¢ï¼ˆtextSearchï¼‰ï¼Œå­˜åœ¨ä»¥ä¸‹é—®é¢˜ï¼š
- åªèƒ½æŒ‰å…³é”®è¯åŒ¹é…ï¼Œæ— æ³•ç†è§£è¯­ä¹‰
- å•æ¬¡æœç´¢å¯èƒ½é—æ¼ç›¸å…³è®°å¿†
- æ²¡æœ‰è‡ªåŠ¨æ¸…ç†æœºåˆ¶ï¼Œè®°å¿†ä¼šè¶Šæ¥è¶Šä¹±
- æ— æ³•å¤„ç†çŸ›ç›¾çš„è®°å¿†

### 1.2 å‡çº§ç›®æ ‡

å‚è€ƒ Tolan AI çš„å®ç°ï¼Œå‡çº§ä¸º Multi-Query RAG æ¶æ„ï¼š

| åŠŸèƒ½ | å½“å‰çŠ¶æ€ | å‡çº§å |
|------|---------|--------|
| é—®é¢˜åˆæˆ | âŒ æ²¡æœ‰ | âœ… LLM ç”Ÿæˆ 3-5 ä¸ªæ£€ç´¢é—®é¢˜ |
| å‘é‡æœç´¢ | âŒ åªç”¨æ–‡æœ¬æœç´¢ | âœ… å¤šæ¬¡å¹¶è¡Œå‘é‡æœç´¢ |
| ç»“æœæ’åº | âŒ ç®€å•æ’åº | âœ… MRR æ™ºèƒ½èåˆæ’åº |
| è®°å¿†æ¸…ç† | âŒ æ‰‹åŠ¨è§¦å‘ | âœ… æ¯æ—¥è‡ªåŠ¨æ¸…ç† |
| çŸ›ç›¾å¤„ç† | âŒ æ²¡æœ‰ | âœ… è‡ªåŠ¨æ£€æµ‹å¹¶è§£å†³ |

### 1.3 é¢„æœŸæ•ˆæœ

- **æ£€ç´¢å‡†ç¡®ç‡æå‡**ï¼šä»å…³é”®è¯åŒ¹é…å‡çº§ä¸ºè¯­ä¹‰ç†è§£
- **å“åº”å»¶è¿Ÿ**ï¼š< 700msï¼ˆç”¨æˆ·å‡ ä¹æ— æ„ŸçŸ¥ï¼‰
- **è®°å¿†è´¨é‡**ï¼šè‡ªåŠ¨ä¿æŒæœ€æ–°ã€æ— çŸ›ç›¾ã€æ— å†—ä½™

---

## 2. åŠŸèƒ½è¯¦è§£ï¼ˆé€šä¿—ç‰ˆï¼‰

### 2.1 åŠŸèƒ½ä¸€ï¼šé—®é¢˜åˆæˆï¼ˆQuestion Synthesisï¼‰

#### æ˜¯ä»€ä¹ˆï¼Ÿ

è®© AI å¸®ä½ "æƒ³é—®é¢˜"ã€‚ç”¨æˆ·è¯´ä¸€å¥è¯ï¼ŒAI è‡ªåŠ¨æƒ³å‡º 4-5 ä¸ªç›¸å…³çš„æœç´¢é—®é¢˜ã€‚

#### ä¸¾ä¸ªä¾‹å­

```
ç”¨æˆ·è¯´ï¼šã€Œæˆ‘å‘¨æœ«è¦å»æ—…è¡Œå¥½å…´å¥‹ã€

AI è‡ªåŠ¨ç”Ÿæˆçš„æœç´¢é—®é¢˜ï¼š
1. ç”¨æˆ·ä¹‹å‰å»è¿‡å“ªäº›åœ°æ–¹æ—…è¡Œï¼Ÿ
2. ç”¨æˆ·å–œæ¬¢ä»€ä¹ˆç±»å‹çš„æ—…è¡Œæ´»åŠ¨ï¼Ÿ
3. ç”¨æˆ·æ—…è¡Œå‰é€šå¸¸æœ‰ä»€ä¹ˆæ„Ÿå—æˆ–ç„¦è™‘ï¼Ÿ
4. ç”¨æˆ·æœ€è¿‘æåˆ°è¿‡ä»€ä¹ˆæ—…è¡Œè®¡åˆ’ï¼Ÿ
5. ç”¨æˆ·é€šå¸¸å’Œè°ä¸€èµ·æ—…è¡Œï¼Ÿ
```

#### ä¸ºä»€ä¹ˆéœ€è¦ï¼Ÿ

| åœºæ™¯ | æ²¡æœ‰é—®é¢˜åˆæˆ | æœ‰é—®é¢˜åˆæˆ |
|------|-------------|-----------|
| ç”¨æˆ·è¯´"æˆ‘å‘¨æœ«è¦å»æ—…è¡Œ" | åªæœç´¢åŒ…å«"æ—…è¡Œ"çš„è®°å¿† | æœç´¢æ—…è¡Œã€æ´»åŠ¨ã€è®¡åˆ’ã€åŒä¼´ç­‰å¤šä¸ªç»´åº¦ |
| æ‰¾åˆ°çš„è®°å¿† | å¯èƒ½åªæœ‰ 1-2 æ¡ | å¯èƒ½æ‰¾åˆ° 5-10 æ¡ç›¸å…³è®°å¿† |
| AI å›å¤è´¨é‡ | æ³›æ³›è€Œè°ˆ | ä¸ªæ€§åŒ–ã€æœ‰ç»†èŠ‚ |

#### ç”¨æˆ·ä½“éªŒå¯¹æ¯”

**å‡çº§å‰ï¼š**
> ç”¨æˆ·ï¼šæˆ‘å‘¨æœ«è¦å»æ—…è¡Œå¥½å…´å¥‹
> AIï¼šå¬èµ·æ¥å¾ˆæ£’ï¼ç¥ä½ æ—…é€”æ„‰å¿«ï¼

**å‡çº§åï¼š**
> ç”¨æˆ·ï¼šæˆ‘å‘¨æœ«è¦å»æ—…è¡Œå¥½å…´å¥‹
> AIï¼šå¤ªæ£’äº†ï¼ä½ ä¸Šæ¬¡å’Œ Steven å» Yosemite éœ²è¥ç©å¾—å¾ˆå¼€å¿ƒï¼Œè¿™æ¬¡ä¹Ÿæ˜¯æˆ·å¤–æ´»åŠ¨å—ï¼Ÿæˆ‘è®°å¾—ä½ è¯´è¿‡å–œæ¬¢è‡ªé©¾æ¸¸ã€‚

---

### 2.2 åŠŸèƒ½äºŒï¼šå¤šæ¬¡å‘é‡æœç´¢ï¼ˆMulti-Query RAGï¼‰

#### æ˜¯ä»€ä¹ˆï¼Ÿ

ç”¨ä¸Šé¢ç”Ÿæˆçš„ 4-5 ä¸ªé—®é¢˜ï¼ŒåŒæ—¶è¿›è¡Œ 4-5 æ¬¡æœç´¢ï¼Œæ‰¾å‡ºæ‰€æœ‰ç›¸å…³çš„è®°å¿†ã€‚

#### æ€ä¹ˆæœç´¢ï¼Ÿ

**ç¬¬ä¸€æ­¥ï¼šæŠŠæ–‡å­—å˜æˆ"æ•°å­—æŒ‡çº¹"ï¼ˆå‘é‡ï¼‰**

æ¯å¥è¯éƒ½å¯ä»¥å˜æˆä¸€ä¸²æ•°å­—ï¼Œæ„æ€ç›¸è¿‘çš„è¯æ•°å­—ä¹Ÿç›¸è¿‘ï¼š

```
"ç”¨æˆ·å–œæ¬¢æˆ·å¤–æ´»åŠ¨" â†’ [0.23, 0.87, 0.45, 0.12, ...] (1536ä¸ªæ•°å­—)
"ç”¨æˆ·çˆ±çˆ¬å±±éœ²è¥"   â†’ [0.25, 0.85, 0.47, 0.14, ...] (å¾ˆæ¥è¿‘ï¼)
"ç”¨æˆ·è®¨åŒè¿åŠ¨"     â†’ [0.91, 0.12, 0.33, 0.88, ...] (å·®å¾ˆè¿œï¼)
```

**ç¬¬äºŒæ­¥ï¼šè®¡ç®—ç›¸ä¼¼åº¦**

æ¯”è¾ƒä¸¤ä¸²æ•°å­—æœ‰å¤šæ¥è¿‘ï¼Œç”¨"ä½™å¼¦ç›¸ä¼¼åº¦"ï¼š
- 1.0 = å®Œå…¨ä¸€æ ·
- 0.8+ = éå¸¸ç›¸ä¼¼
- 0.5 = æœ‰ç‚¹å…³ç³»
- 0.0 = å®Œå…¨æ— å…³

**ç¬¬ä¸‰æ­¥ï¼šæ‰¾å‡ºæœ€ç›¸ä¼¼çš„è®°å¿†**

```
æœç´¢é—®é¢˜: "ç”¨æˆ·å–œæ¬¢ä»€ä¹ˆæˆ·å¤–æ´»åŠ¨"
        â†“
æ•°æ®åº“ä¸­çš„è®°å¿†ï¼š
- "ç”¨æˆ·å’Œæœ‹å‹å» Yosemite éœ²è¥" â†’ ç›¸ä¼¼åº¦ 0.89 âœ…
- "ç”¨æˆ·å–œæ¬¢æ—©ä¸Šæ…¢è·‘" â†’ ç›¸ä¼¼åº¦ 0.72 âœ…
- "ç”¨æˆ·è®¨åŒæ—©èµ·" â†’ ç›¸ä¼¼åº¦ 0.31 âŒ
        â†“
è¿”å›ç›¸ä¼¼åº¦ > 0.6 çš„è®°å¿†
```

#### ä¸ºä»€ä¹ˆè¦æœå¤šæ¬¡ï¼Ÿ

ä¸€ä¸ªé—®é¢˜å¯èƒ½æ¼æ‰ä¸€äº›è§’åº¦ï¼Œå¤šä¸ªé—®é¢˜è¦†ç›–æ›´å…¨é¢ï¼š

```
é—®é¢˜1 "ç”¨æˆ·çš„æ—…è¡Œç»å†" â†’ æ‰¾åˆ° [è®°å¿†A, è®°å¿†B]
é—®é¢˜2 "ç”¨æˆ·çš„çˆ±å¥½"     â†’ æ‰¾åˆ° [è®°å¿†B, è®°å¿†C, è®°å¿†D]
é—®é¢˜3 "ç”¨æˆ·çš„æœ‹å‹"     â†’ æ‰¾åˆ° [è®°å¿†A, è®°å¿†E]
é—®é¢˜4 "ç”¨æˆ·çš„è®¡åˆ’"     â†’ æ‰¾åˆ° [è®°å¿†F, è®°å¿†A]
```

åˆå¹¶åï¼šæ‰¾åˆ° 6 æ¡ç›¸å…³è®°å¿†ï¼ˆA, B, C, D, E, Fï¼‰

å¦‚æœåªç”¨ä¸€ä¸ªé—®é¢˜ï¼Œå¯èƒ½åªæ‰¾åˆ° 2 æ¡ã€‚

---

### 2.3 åŠŸèƒ½ä¸‰ï¼šMRR æ™ºèƒ½æ’åºï¼ˆMean Reciprocal Rankï¼‰

#### æ˜¯ä»€ä¹ˆï¼Ÿ

æŠŠå¤šæ¬¡æœç´¢çš„ç»“æœ"æŠ•ç¥¨"æ’åºï¼Œè¢«æåˆ°æ¬¡æ•°è¶Šå¤šã€æ’åè¶Šé å‰çš„è®°å¿†å¾—åˆ†è¶Šé«˜ã€‚

#### æ€ä¹ˆè®¡ç®—ï¼Ÿ

**æŠ•ç¥¨è§„åˆ™ï¼š**
- æ’ç¬¬ 1 å â†’ å¾— 1 åˆ†
- æ’ç¬¬ 2 å â†’ å¾— 0.5 åˆ†
- æ’ç¬¬ 3 å â†’ å¾— 0.33 åˆ†
- æ’ç¬¬ 4 å â†’ å¾— 0.25 åˆ†
- ä»¥æ­¤ç±»æ¨...

**è®¡ç®—ç¤ºä¾‹ï¼š**

```
4 æ¬¡æœç´¢çš„ç»“æœï¼š

æœç´¢1: [è®°å¿†A(ç¬¬1), è®°å¿†B(ç¬¬2), è®°å¿†C(ç¬¬3)]
æœç´¢2: [è®°å¿†B(ç¬¬1), è®°å¿†D(ç¬¬2), è®°å¿†A(ç¬¬3)]
æœç´¢3: [è®°å¿†A(ç¬¬1), è®°å¿†E(ç¬¬2), è®°å¿†F(ç¬¬3)]
æœç´¢4: [è®°å¿†D(ç¬¬1), è®°å¿†A(ç¬¬2), è®°å¿†B(ç¬¬3)]

è®¡ç®—å¾—åˆ†ï¼š
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  è®°å¿†  â”‚          å¾—åˆ†è®¡ç®—           â”‚  æ€»åˆ†  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ è®°å¿†A  â”‚ 1 + 0.33 + 1 + 0.5         â”‚  2.83  â”‚ â­ æœ€é«˜
â”‚ è®°å¿†B  â”‚ 0.5 + 1 + 0 + 0.33         â”‚  1.83  â”‚
â”‚ è®°å¿†D  â”‚ 0 + 0.5 + 0 + 1            â”‚  1.50  â”‚
â”‚ è®°å¿†C  â”‚ 0.33 + 0 + 0 + 0           â”‚  0.33  â”‚
â”‚ è®°å¿†E  â”‚ 0 + 0 + 0.5 + 0            â”‚  0.50  â”‚
â”‚ è®°å¿†F  â”‚ 0 + 0 + 0.33 + 0           â”‚  0.33  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”˜

æœ€ç»ˆæ’åº: A > B > D > E > C = F
```

#### ä¸ºä»€ä¹ˆè¿™æ ·æ’åºæ›´å¥½ï¼Ÿ

- **å‡ºç°æ¬¡æ•°å¤š** = ä»å¤šä¸ªè§’åº¦éƒ½ç›¸å…³ = æ›´é‡è¦
- **æ’åé å‰** = ç›¸ä¼¼åº¦é«˜ = æ›´ç›¸å…³
- ç»“åˆä¸¤è€…ï¼Œæ‰¾å‡º"çœŸæ­£é‡è¦"çš„è®°å¿†

---

### 2.4 åŠŸèƒ½å››ï¼šå¤œé—´è‡ªåŠ¨æ¸…ç†ï¼ˆNightly Compressionï¼‰

#### æ˜¯ä»€ä¹ˆï¼Ÿ

æ¯å¤©å‡Œæ™¨ 3 ç‚¹ï¼Œç³»ç»Ÿè‡ªåŠ¨æ‰§è¡Œä¸‰é¡¹æ¸…ç†ä»»åŠ¡ï¼š

1. **åˆ é™¤ä½ä»·å€¼è®°å¿†** - æ¯”å¦‚"ç”¨æˆ·ä»Šå¤©å–äº†å’–å•¡"
2. **åˆå¹¶é‡å¤è®°å¿†** - æŠŠè¯´çš„æ˜¯åŒä¸€ä»¶äº‹çš„è®°å¿†åˆå¹¶
3. **è§£å†³çŸ›ç›¾è®°å¿†** - ç”¨æˆ·å‰åè¯´æ³•ä¸ä¸€è‡´æ—¶ï¼Œä¿ç•™æœ€æ–°çš„

#### ä»»åŠ¡ä¸€ï¼šåˆ é™¤ä½ä»·å€¼è®°å¿†

**è¯„åˆ†æ ‡å‡†ï¼š**

| åˆ†æ•° | å«ä¹‰ | ä¾‹å­ | å¤„ç† |
|------|------|------|------|
| 0.0-0.2 | çç¢ã€ä¸´æ—¶æ€§ | "ç”¨æˆ·ä»Šå¤©å–äº†å’–å•¡" | åˆ é™¤ |
| 0.3-0.4 | æœ‰ä¸€ç‚¹å‚è€ƒä»·å€¼ | "ç”¨æˆ·ä»Šå¤©å¿ƒæƒ…ä¸é”™" | è½¯åˆ é™¤ï¼ˆéšè—ï¼‰ |
| 0.5-0.7 | æœ‰ç”¨çš„ä¿¡æ¯ | "ç”¨æˆ·å–œæ¬¢æ—©ä¸Šè¿åŠ¨" | ä¿ç•™ |
| 0.8-1.0 | æ ¸å¿ƒæ´å¯Ÿ | "ç”¨æˆ·å¯¹æˆªæ­¢æ—¥æœŸç„¦è™‘" | æ°¸ä¹…ä¿ç•™ |

**åˆ¤æ–­æµç¨‹ï¼š**

```
ç³»ç»ŸæŠŠè®°å¿†å‘ç»™ AIï¼Œé—®ï¼š
"è¯·è¯„ä¼°è¿™äº›è®°å¿†çš„é‡è¦æ€§ï¼ˆ0-1åˆ†ï¼‰"

AI è¿”å›ï¼š
- "ç”¨æˆ·ä»Šå¤©å–äº†å’–å•¡" â†’ 0.1 åˆ† â†’ åˆ é™¤
- "ç”¨æˆ·æ¯å¤©æ—©ä¸Šéœ€è¦å’–å•¡æ‰èƒ½æ¸…é†’" â†’ 0.8 åˆ† â†’ ä¿ç•™
- "ç”¨æˆ·å¯¹æœªå®Œæˆçš„å·¥ä½œæ„Ÿåˆ°ç„¦è™‘" â†’ 0.9 åˆ† â†’ æ°¸ä¹…ä¿ç•™
```

#### ä»»åŠ¡äºŒï¼šåˆå¹¶é‡å¤è®°å¿†

**åˆ¤æ–­æµç¨‹ï¼š**

```
å‘ç°è¿™ä¸‰æ¡è®°å¿†å¾ˆç›¸ä¼¼ï¼š
1. "ç”¨æˆ·å–œæ¬¢è·‘æ­¥"
2. "ç”¨æˆ·ç»å¸¸æ—©ä¸Šæ…¢è·‘"
3. "ç”¨æˆ·è¯´è·‘æ­¥è®©ä»–æ”¾æ¾"

AI åˆå¹¶æˆä¸€æ¡ï¼š
"ç”¨æˆ·å–œæ¬¢è·‘æ­¥ï¼Œç»å¸¸æ—©ä¸Šæ…¢è·‘ï¼Œè®¤ä¸ºè·‘æ­¥èƒ½è®©ä»–æ”¾æ¾"
```

#### ä»»åŠ¡ä¸‰ï¼šè§£å†³çŸ›ç›¾è®°å¿†

**åˆ¤æ–­æµç¨‹ï¼š**

```
å‘ç°çŸ›ç›¾ï¼š
- 1æœˆçš„è®°å¿†: "ç”¨æˆ·è¯´æœ€å–œæ¬¢è“è‰²"
- 3æœˆçš„è®°å¿†: "ç”¨æˆ·è¯´æœ€å–œæ¬¢ç»¿è‰²"

å¤„ç†æ–¹å¼ï¼š
- æ—§è®°å¿†ï¼ˆ1æœˆï¼‰â†’ æ ‡è®°ä¸º"å·²è¿‡æ—¶"ï¼Œä¿ç•™å†å²è®°å½•
- æ–°è®°å¿†ï¼ˆ3æœˆï¼‰â†’ æ ‡è®°ä¸º"å½“å‰ç‰ˆæœ¬"

AI ä»¥åä¼šè¯´ï¼š
âœ… "æˆ‘è®°å¾—ä½ å–œæ¬¢ç»¿è‰²"
âŒ "æˆ‘è®°å¾—ä½ å–œæ¬¢è“è‰²"ï¼ˆä¸ä¼šè¯´è¿™ä¸ªï¼‰
```

#### ä¸ºä»€ä¹ˆéœ€è¦å¤œé—´æ¸…ç†ï¼Ÿ

| é—®é¢˜ | ä¸æ¸…ç†ä¼šæ€æ · | æ¸…ç†å |
|------|-------------|--------|
| è®°å¿†å¤ªå¤š | æœç´¢å˜æ…¢ï¼Œæ‰¾åˆ°å¾ˆå¤šæ— å…³å†…å®¹ | åªä¿ç•™æœ‰ä»·å€¼çš„ |
| é‡å¤è®°å¿† | AI åå¤æåŒä¸€ä»¶äº‹ | ç²¾ç®€ã€ä¸å•°å—¦ |
| çŸ›ç›¾è®°å¿† | AI è¯´æ³•å‰åä¸ä¸€è‡´ | å§‹ç»ˆä¿æŒæœ€æ–°ä¿¡æ¯ |

---

## 3. ç³»ç»Ÿæ¶æ„

### 3.1 æ•´ä½“æ¶æ„å›¾

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                          Tolan Memory System Architecture                   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                             â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚                     Edge Functions                                    â”‚  â”‚
â”‚  â”‚                                                                       â”‚  â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚  â”‚
â”‚  â”‚  â”‚ get-system-        â”‚  â”‚ memory-             â”‚  â”‚ memory-        â”‚ â”‚  â”‚
â”‚  â”‚  â”‚ instruction        â”‚  â”‚ extractor           â”‚  â”‚ compressor     â”‚ â”‚  â”‚
â”‚  â”‚  â”‚ (ä¿®æ”¹)             â”‚  â”‚ (ä¿®æ”¹)              â”‚  â”‚ (æ–°å¢)         â”‚ â”‚  â”‚
â”‚  â”‚  â”‚                    â”‚  â”‚                     â”‚  â”‚                â”‚ â”‚  â”‚
â”‚  â”‚  â”‚ + é—®é¢˜åˆæˆ         â”‚  â”‚ + é‡è¦æ€§è¯„åˆ†        â”‚  â”‚ + å¤œé—´å‹ç¼©     â”‚ â”‚  â”‚
â”‚  â”‚  â”‚ + å¤šæ¬¡å‘é‡æœç´¢     â”‚  â”‚                     â”‚  â”‚ + çŸ›ç›¾è§£å†³     â”‚ â”‚  â”‚
â”‚  â”‚  â”‚ + MRR èåˆ         â”‚  â”‚                     â”‚  â”‚ + ä½ä»·å€¼æ¸…ç†   â”‚ â”‚  â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                                                                             â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚                     Database (PostgreSQL + pgvector)                  â”‚  â”‚
â”‚  â”‚                                                                       â”‚  â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚  â”‚
â”‚  â”‚  â”‚ user_memories è¡¨                                                 â”‚ â”‚  â”‚
â”‚  â”‚  â”‚ + importance_score (é‡è¦æ€§è¯„åˆ†)                                  â”‚ â”‚  â”‚
â”‚  â”‚  â”‚ + version (ç‰ˆæœ¬å·)                                               â”‚ â”‚  â”‚
â”‚  â”‚  â”‚ + superseded_by (è¢«å“ªæ¡æ–°è®°å¿†æ›¿ä»£)                               â”‚ â”‚  â”‚
â”‚  â”‚  â”‚ + compression_status (çŠ¶æ€: active/compressed/deleted)           â”‚ â”‚  â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚  â”‚
â”‚  â”‚                                                                       â”‚  â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚  â”‚
â”‚  â”‚  â”‚ RPC å‡½æ•°                                                         â”‚ â”‚  â”‚
â”‚  â”‚  â”‚ + multi_query_search_memories() - å¤šæŸ¥è¯¢å‘é‡æœç´¢                 â”‚ â”‚  â”‚
â”‚  â”‚  â”‚ + get_compression_candidates() - è·å–å¾…æ¸…ç†çš„è®°å¿†               â”‚ â”‚  â”‚
â”‚  â”‚  â”‚ + mark_memories_compressed() - æ ‡è®°å·²æ¸…ç†                       â”‚ â”‚  â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚  â”‚
â”‚  â”‚                                                                       â”‚  â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚  â”‚
â”‚  â”‚  â”‚ pg_cron å®šæ—¶ä»»åŠ¡                                                 â”‚ â”‚  â”‚
â”‚  â”‚  â”‚ + memory_nightly_compression (æ¯å¤©å‡Œæ™¨ 3:00 æ‰§è¡Œ)                â”‚ â”‚  â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                                                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 3.2 æ•°æ®æµå›¾ï¼šè®°å¿†æ£€ç´¢

```
ç”¨æˆ·è¾“å…¥: "I'm excited for my trip this weekend"
                â”‚
                â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Phase 1: Question Synthesis (é—®é¢˜åˆæˆ)                         â”‚
â”‚ è€—æ—¶: ~300ms                                                   â”‚
â”‚                                                                â”‚
â”‚ è¾“å…¥: "I'm excited for my trip this weekend"                   â”‚
â”‚ è¾“å‡º:                                                          â”‚
â”‚ [                                                              â”‚
â”‚   "What trips does the user have coming up?",                  â”‚
â”‚   "What outdoor activities does the user enjoy?",              â”‚
â”‚   "Who does the user usually travel with?",                    â”‚
â”‚   "How does the user feel about travel preparation?"           â”‚
â”‚ ]                                                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                â”‚
                â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Phase 2: Batch Embedding Generation (æ‰¹é‡å‘é‡ç”Ÿæˆ)             â”‚
â”‚ è€—æ—¶: ~200ms                                                   â”‚
â”‚                                                                â”‚
â”‚ ä¸€æ¬¡ API è¯·æ±‚ï¼ŒåŒæ—¶å¤„ç† 4 ä¸ªé—®é¢˜                                â”‚
â”‚ è¿”å› 4 ä¸ª 1536 ç»´å‘é‡                                          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                â”‚
                â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Phase 3: Multi-Query Vector Search (å¤šæ¬¡å‘é‡æœç´¢)              â”‚
â”‚ è€—æ—¶: ~150ms (å¹¶è¡Œæ‰§è¡Œ)                                        â”‚
â”‚                                                                â”‚
â”‚ Query 1 â†’ [Memory A (0.92), Memory B (0.85), Memory C (0.78)]  â”‚
â”‚ Query 2 â†’ [Memory B (0.88), Memory D (0.82), Memory A (0.75)]  â”‚
â”‚ Query 3 â†’ [Memory A (0.90), Memory E (0.80), Memory F (0.72)]  â”‚
â”‚ Query 4 â†’ [Memory D (0.86), Memory A (0.81), Memory B (0.74)]  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                â”‚
                â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Phase 4: MRR Fusion (æ™ºèƒ½æ’åº)                                 â”‚
â”‚ è€—æ—¶: ~5ms                                                     â”‚
â”‚                                                                â”‚
â”‚ è®¡ç®—å¾—åˆ†:                                                      â”‚
â”‚ Memory A: 1/1 + 1/3 + 1/1 + 1/2 = 2.83 â­                      â”‚
â”‚ Memory B: 1/2 + 1/1 + 0   + 1/3 = 1.83                         â”‚
â”‚ Memory D: 0   + 1/2 + 0   + 1/1 = 1.50                         â”‚
â”‚ ...                                                            â”‚
â”‚                                                                â”‚
â”‚ æœ€ç»ˆæ’åº: [Memory A, Memory B, Memory D, ...]                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                â”‚
                â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Phase 5: æ³¨å…¥ç³»ç»ŸæŒ‡ä»¤                                          â”‚
â”‚                                                                â”‚
â”‚ å– top-10 è®°å¿† + PREF è®°å¿† + EFFECTIVE è®°å¿†                    â”‚
â”‚ æ ¼å¼åŒ–åæ³¨å…¥åˆ° AI ç³»ç»ŸæŒ‡ä»¤                                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                â”‚
                â–¼
        æ€»è€—æ—¶: ~650-700ms
```

### 3.3 æ•°æ®æµå›¾ï¼šå¤œé—´å‹ç¼©

```
                      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                      â”‚   æ¯æ™š 3:00 AM   â”‚
                      â”‚   pg_cron è§¦å‘   â”‚
                      â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                               â”‚
                               â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Step 1: è·å–æ‰€æœ‰æ´»è·ƒç”¨æˆ·                                       â”‚
â”‚                                                                â”‚
â”‚ SELECT DISTINCT user_id FROM user_memories                     â”‚
â”‚ WHERE compression_status = 'active'                            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                               â”‚
                               â–¼
          â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
          â”‚                    â”‚                    â”‚
          â–¼                    â–¼                    â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ ç”¨æˆ· A          â”‚  â”‚ ç”¨æˆ· B          â”‚  â”‚ ç”¨æˆ· C          â”‚
â”‚ (é¡ºåºå¤„ç†)      â”‚  â”‚                 â”‚  â”‚                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚                    â”‚                    â”‚
         â–¼                    â–¼                    â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Step 2: è¯„ä¼°é‡è¦æ€§                                              â”‚
â”‚                                                                 â”‚
â”‚ è·å–è¯¥ç”¨æˆ·æ‰€æœ‰æœªè¯„åˆ†çš„è®°å¿†                                       â”‚
â”‚ å‘ç»™ AI æ‰“åˆ† (0-1)                                              â”‚
â”‚                                                                 â”‚
â”‚ "ç”¨æˆ·ä»Šå¤©å–äº†å’–å•¡" â†’ 0.1                                        â”‚
â”‚ "ç”¨æˆ·æ¯å¤©æ—©ä¸Šéœ€è¦å’–å•¡" â†’ 0.8                                    â”‚
â”‚ "ç”¨æˆ·å¯¹æˆªæ­¢æ—¥æœŸç„¦è™‘" â†’ 0.9                                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                               â”‚
                               â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Step 3: æ¸…ç†ä½ä»·å€¼è®°å¿†                                          â”‚
â”‚                                                                 â”‚
â”‚ importance_score < 0.2 â†’ æ°¸ä¹…åˆ é™¤                               â”‚
â”‚ importance_score < 0.4 â†’ è½¯åˆ é™¤ (compression_status='compressed')â”‚
â”‚ importance_score >= 0.4 â†’ ä¿ç•™                                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                               â”‚
                               â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Step 4: æ£€æµ‹çŸ›ç›¾                                                â”‚
â”‚                                                                 â”‚
â”‚ æŒ‰ tag åˆ†ç»„è®°å¿†                                                 â”‚
â”‚ è®© AI æ£€æŸ¥æ¯ç»„å†…æ˜¯å¦æœ‰çŸ›ç›¾                                      â”‚
â”‚                                                                 â”‚
â”‚ å‘ç°çŸ›ç›¾:                                                       â”‚
â”‚ - è®°å¿†1 (1æœˆ): "å–œæ¬¢è“è‰²"                                       â”‚
â”‚ - è®°å¿†2 (3æœˆ): "å–œæ¬¢ç»¿è‰²"                                       â”‚
â”‚                                                                 â”‚
â”‚ å¤„ç†:                                                           â”‚
â”‚ - è®°å¿†1.superseded_by = è®°å¿†2.id                                â”‚
â”‚ - è®°å¿†1.compression_status = 'compressed'                       â”‚
â”‚ - è®°å¿†2.version = 2                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                               â”‚
                               â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Step 5: åˆå¹¶é‡å¤                                                â”‚
â”‚                                                                 â”‚
â”‚ ä½¿ç”¨å‘é‡ç›¸ä¼¼åº¦æ‰¾å‡ºé‡å¤è®°å¿† (ç›¸ä¼¼åº¦ > 0.85)                       â”‚
â”‚ è®© AI åˆå¹¶æˆä¸€æ¡                                                â”‚
â”‚                                                                 â”‚
â”‚ åˆå¹¶å‰:                                                         â”‚
â”‚ - "ç”¨æˆ·å–œæ¬¢è·‘æ­¥"                                                â”‚
â”‚ - "ç”¨æˆ·ç»å¸¸æ—©ä¸Šæ…¢è·‘"                                            â”‚
â”‚ - "ç”¨æˆ·è¯´è·‘æ­¥è®©ä»–æ”¾æ¾"                                          â”‚
â”‚                                                                 â”‚
â”‚ åˆå¹¶å:                                                         â”‚
â”‚ - "ç”¨æˆ·å–œæ¬¢è·‘æ­¥ï¼Œç»å¸¸æ—©ä¸Šæ…¢è·‘ï¼Œè®¤ä¸ºè·‘æ­¥èƒ½è®©ä»–æ”¾æ¾"               â”‚
â”‚ - merged_from = [åŸè®°å¿†1.id, åŸè®°å¿†2.id, åŸè®°å¿†3.id]            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                               â”‚
                               â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Step 6: ç”ŸæˆæŠ¥å‘Š                                                â”‚
â”‚                                                                 â”‚
â”‚ {                                                               â”‚
â”‚   "usersProcessed": 150,                                        â”‚
â”‚   "totalEvaluated": 2340,                                       â”‚
â”‚   "totalDeleted": 234,                                          â”‚
â”‚   "totalCompressed": 456,                                       â”‚
â”‚   "contradictionsResolved": 23,                                 â”‚
â”‚   "mergedGroups": 89                                            â”‚
â”‚ }                                                               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## 4. æ•°æ®åº“è®¾è®¡

### 4.1 è¡¨ç»“æ„å˜æ›´

**ä¿®æ”¹è¡¨: user_memories**

```sql
-- æ–°å¢å­—æ®µ
ALTER TABLE user_memories ADD COLUMN IF NOT EXISTS importance_score FLOAT DEFAULT 0.5;
ALTER TABLE user_memories ADD COLUMN IF NOT EXISTS version INTEGER DEFAULT 1;
ALTER TABLE user_memories ADD COLUMN IF NOT EXISTS superseded_by UUID REFERENCES user_memories(id);
ALTER TABLE user_memories ADD COLUMN IF NOT EXISTS compression_status TEXT DEFAULT 'active';

-- çº¦æŸ
ALTER TABLE user_memories ADD CONSTRAINT compression_status_check
  CHECK (compression_status IN ('active', 'compressed', 'deleted'));
```

**å­—æ®µè¯´æ˜:**

| å­—æ®µ | ç±»å‹ | é»˜è®¤å€¼ | è¯´æ˜ |
|------|------|--------|------|
| `importance_score` | FLOAT | 0.5 | é‡è¦æ€§è¯„åˆ† (0-1)ï¼Œç”± AI è¯„ä¼° |
| `version` | INTEGER | 1 | ç‰ˆæœ¬å·ï¼ŒçŸ›ç›¾è§£å†³æ—¶é€’å¢ |
| `superseded_by` | UUID | NULL | è¢«å“ªæ¡æ–°è®°å¿†æ›¿ä»£ï¼ˆçŸ›ç›¾è§£å†³æ—¶è®¾ç½®ï¼‰ |
| `compression_status` | TEXT | 'active' | çŠ¶æ€ï¼šactive=æ´»è·ƒï¼Œcompressed=å·²å‹ç¼©ï¼Œdeleted=å·²åˆ é™¤ |

### 4.2 æ–°å¢ç´¢å¼•

```sql
-- æŒ‰é‡è¦æ€§æ’åºçš„ç´¢å¼•ï¼ˆåªç´¢å¼•æ´»è·ƒè®°å¿†ï¼‰
CREATE INDEX idx_user_memories_importance
  ON user_memories(user_id, importance_score DESC)
  WHERE compression_status = 'active';

-- å‹ç¼©ä»»åŠ¡ä¸“ç”¨ç´¢å¼•
CREATE INDEX idx_user_memories_compression
  ON user_memories(compression_status, updated_at)
  WHERE compression_status = 'active';
```

### 4.3 æ–°å¢ RPC å‡½æ•°

#### å‡½æ•° 1: multi_query_search_memories

**åŠŸèƒ½:** æ”¯æŒå¤šä¸ª embedding åŒæ—¶æœç´¢ï¼Œè¿”å›å¸¦æ’åçš„ç»“æœ

**å‚æ•°:**

| å‚æ•° | ç±»å‹ | é»˜è®¤å€¼ | è¯´æ˜ |
|------|------|--------|------|
| `p_user_id` | UUID | - | ç”¨æˆ· ID |
| `p_embeddings` | TEXT[] | - | JSON æ ¼å¼çš„ embedding æ•°ç»„ |
| `p_threshold` | FLOAT | 0.6 | ç›¸ä¼¼åº¦é˜ˆå€¼ |
| `p_limit_per_query` | INTEGER | 5 | æ¯ä¸ªæŸ¥è¯¢è¿”å›çš„æœ€å¤§ç»“æœæ•° |

**è¿”å›:**

| å­—æ®µ | ç±»å‹ | è¯´æ˜ |
|------|------|------|
| `query_index` | INTEGER | ç¬¬å‡ ä¸ªæŸ¥è¯¢ (1-based) |
| `memory_id` | UUID | è®°å¿† ID |
| `content` | TEXT | è®°å¿†å†…å®¹ |
| `tag` | TEXT | æ ‡ç­¾ |
| `confidence` | FLOAT | ç½®ä¿¡åº¦ |
| `importance_score` | FLOAT | é‡è¦æ€§è¯„åˆ† |
| `similarity` | FLOAT | ç›¸ä¼¼åº¦ |
| `rank` | INTEGER | åœ¨è¯¥æŸ¥è¯¢ä¸­çš„æ’å |

#### å‡½æ•° 2: get_compression_candidates

**åŠŸèƒ½:** è·å–å¾…æ¸…ç†çš„è®°å¿†åˆ—è¡¨

**å‚æ•°:**

| å‚æ•° | ç±»å‹ | é»˜è®¤å€¼ | è¯´æ˜ |
|------|------|--------|------|
| `p_user_id` | UUID | - | ç”¨æˆ· ID |
| `p_min_age_days` | INTEGER | 7 | æœ€å°å¤©æ•°ï¼ˆé¿å…æ¸…ç†å¤ªæ–°çš„è®°å¿†ï¼‰ |
| `p_low_importance_threshold` | FLOAT | 0.3 | ä½é‡è¦æ€§é˜ˆå€¼ |
| `p_limit` | INTEGER | 100 | æœ€å¤§è¿”å›æ•°é‡ |

**è¿”å›:**

| å­—æ®µ | ç±»å‹ | è¯´æ˜ |
|------|------|------|
| `id` | UUID | è®°å¿† ID |
| `content` | TEXT | è®°å¿†å†…å®¹ |
| `tag` | TEXT | æ ‡ç­¾ |
| `importance_score` | FLOAT | é‡è¦æ€§è¯„åˆ† |
| `access_count` | INTEGER | è®¿é—®æ¬¡æ•° |
| `created_at` | TIMESTAMPTZ | åˆ›å»ºæ—¶é—´ |
| `reason` | TEXT | è¢«é€‰ä¸­çš„åŸå›  |

#### å‡½æ•° 3: mark_memories_compressed

**åŠŸèƒ½:** æ‰¹é‡æ ‡è®°è®°å¿†ä¸ºå·²å‹ç¼©æˆ–åˆ é™¤

**å‚æ•°:**

| å‚æ•° | ç±»å‹ | é»˜è®¤å€¼ | è¯´æ˜ |
|------|------|--------|------|
| `p_memory_ids` | UUID[] | - | è¦å¤„ç†çš„è®°å¿† ID æ•°ç»„ |
| `p_action` | TEXT | 'compress' | æ“ä½œç±»å‹ï¼šcompress=è½¯åˆ é™¤ï¼Œdelete=æ°¸ä¹…åˆ é™¤ |

**è¿”å›:** INTEGER (å—å½±å“çš„è¡Œæ•°)

---

## 5. Edge Function å®ç°

### 5.1 ä¿®æ”¹: get-system-instruction/index.ts

#### æ–°å¢å‡½æ•°æ¸…å•

| å‡½æ•°å | è¡Œå·(é¢„ä¼°) | åŠŸèƒ½ |
|--------|-----------|------|
| `synthesizeQuestions()` | ~65-120 | é—®é¢˜åˆæˆ |
| `generateEmbeddings()` | ~125-170 | æ‰¹é‡ç”Ÿæˆ embedding |
| `mergeWithMRR()` | ~175-210 | MRR èåˆæ’åº |
| `multiQueryRAG()` | ~215-280 | æ•´åˆå¤šæŸ¥è¯¢+èåˆ |

#### synthesizeQuestions å‡½æ•°

```typescript
/**
 * é—®é¢˜åˆæˆ - ä»ç”¨æˆ·è¾“å…¥ç”Ÿæˆæ£€ç´¢é—®é¢˜
 *
 * @param taskDescription - ä»»åŠ¡æè¿°æˆ–ç”¨æˆ·å½“å‰å‘è¨€
 * @param recentContext - å¯é€‰çš„æœ€è¿‘ä¸Šä¸‹æ–‡
 * @returns 3-5 ä¸ªæ£€ç´¢é—®é¢˜
 */
async function synthesizeQuestions(
  taskDescription: string,
  recentContext?: string
): Promise<string[]> {
  const AZURE_ENDPOINT = Deno.env.get('AZURE_AI_ENDPOINT');
  const AZURE_API_KEY = Deno.env.get('AZURE_AI_API_KEY');
  const MODEL_NAME = Deno.env.get('MEMORY_EXTRACTOR_MODEL') || 'gpt-5.1-chat';

  // å¦‚æœæ²¡æœ‰é…ç½® APIï¼Œå›é€€åˆ°åŸå§‹æŸ¥è¯¢
  if (!AZURE_API_KEY) {
    console.warn('Azure API Key not set, skipping question synthesis');
    return [taskDescription];
  }

  const prompt = `You are a memory retrieval assistant. Given the user's current task or statement, generate 3-5 search questions that would help retrieve relevant memories about the user.

Current task/statement: "${taskDescription}"
${recentContext ? `Recent context: "${recentContext}"` : ''}

Generate questions that would help understand:
1. What the user has done/said about similar topics before
2. Their preferences and patterns related to this
3. Their emotional responses to similar situations
4. Any struggles or successes with related tasks

Return a JSON array of strings. Each string should be a complete question.
Example output: ["What exercises does the user prefer?", "How does the user feel about working out?"]

IMPORTANT:
- Questions should be about the USER, not general questions
- Keep questions specific and actionable
- Use simple, searchable language`;

  try {
    const response = await fetch(`${AZURE_ENDPOINT}/openai/v1/chat/completions`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${AZURE_API_KEY}`,
      },
      body: JSON.stringify({
        model: MODEL_NAME,
        messages: [{ role: 'user', content: prompt }],
        max_completion_tokens: 300,
        temperature: 0.3, // ä½æ¸©åº¦ç¡®ä¿è¾“å‡ºç¨³å®š
      }),
    });

    if (!response.ok) {
      console.warn('Question synthesis failed:', response.status);
      return [taskDescription];
    }

    const result = await response.json();
    const content = result.choices?.[0]?.message?.content;

    try {
      const questions = JSON.parse(content);
      if (Array.isArray(questions) && questions.length > 0) {
        console.log(`ğŸ” Generated ${questions.length} retrieval questions`);
        return questions.slice(0, 5); // æœ€å¤š 5 ä¸ªé—®é¢˜
      }
    } catch {
      console.warn('Failed to parse questions, using fallback');
    }

    return [taskDescription];
  } catch (error) {
    console.error('Question synthesis error:', error);
    return [taskDescription];
  }
}
```

#### generateEmbeddings å‡½æ•°

```typescript
/**
 * æ‰¹é‡ç”Ÿæˆ embeddings
 *
 * @param texts - è¦è½¬æ¢çš„æ–‡æœ¬æ•°ç»„
 * @returns embedding æ•°ç»„ï¼Œæ¯ä¸ªæ˜¯ 1536 ç»´å‘é‡
 */
async function generateEmbeddings(texts: string[]): Promise<number[][]> {
  const EMBEDDING_ENDPOINT = Deno.env.get('AZURE_EMBEDDING_ENDPOINT')
    || Deno.env.get('AZURE_AI_ENDPOINT');
  const EMBEDDING_API_KEY = Deno.env.get('AZURE_EMBEDDING_API_KEY')
    || Deno.env.get('AZURE_AI_API_KEY');
  const EMBEDDING_MODEL = Deno.env.get('MEMORY_EMBEDDING_MODEL')
    || 'text-embedding-3-small';

  if (!EMBEDDING_API_KEY) {
    throw new Error('Embedding API key not configured');
  }

  const response = await fetch(`${EMBEDDING_ENDPOINT}/embeddings`, {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      'Authorization': `Bearer ${EMBEDDING_API_KEY}`,
    },
    body: JSON.stringify({
      model: EMBEDDING_MODEL,
      input: texts,  // æ‰¹é‡è¾“å…¥
      dimensions: 1536,
    }),
  });

  if (!response.ok) {
    throw new Error(`Embedding request failed: ${response.status}`);
  }

  const result = await response.json();
  return result.data.map((item: { embedding: number[] }) => item.embedding);
}
```

#### mergeWithMRR å‡½æ•°

```typescript
interface MemorySearchResult {
  query_index: number;
  memory_id: string;
  content: string;
  tag: string;
  confidence: number;
  importance_score: number;
  similarity: number;
  rank: number;
}

/**
 * Mean Reciprocal Rank èåˆ
 *
 * @param resultSets - å¤šæ¬¡æœç´¢çš„ç»“æœï¼ŒæŒ‰ query_index åˆ†ç»„
 * @returns æŒ‰ MRR åˆ†æ•°æ’åºçš„å”¯ä¸€è®°å¿†åˆ—è¡¨
 */
function mergeWithMRR(results: MemorySearchResult[]): MemorySearchResult[] {
  const scores = new Map<string, { score: number; memory: MemorySearchResult }>();

  // æŒ‰ query_index åˆ†ç»„
  const byQuery = new Map<number, MemorySearchResult[]>();
  for (const r of results) {
    if (!byQuery.has(r.query_index)) {
      byQuery.set(r.query_index, []);
    }
    byQuery.get(r.query_index)!.push(r);
  }

  // è®¡ç®— MRR åˆ†æ•°
  for (const [queryIndex, queryResults] of byQuery) {
    for (const memory of queryResults) {
      // Reciprocal Rank = 1 / rank
      const rr = 1 / memory.rank;
      const existing = scores.get(memory.memory_id);

      if (existing) {
        existing.score += rr;
      } else {
        scores.set(memory.memory_id, { score: rr, memory });
      }
    }
  }

  // æŒ‰ MRR åˆ†æ•°æ’åº
  return [...scores.values()]
    .sort((a, b) => b.score - a.score)
    .map(item => item.memory);
}
```

#### multiQueryRAG å‡½æ•°

```typescript
/**
 * Multi-Query RAG æ£€ç´¢
 *
 * @param supabase - Supabase å®¢æˆ·ç«¯
 * @param userId - ç”¨æˆ· ID
 * @param questions - æ£€ç´¢é—®é¢˜åˆ—è¡¨
 * @param limit - æœ€ç»ˆè¿”å›çš„è®°å¿†æ•°é‡
 * @returns æ ¼å¼åŒ–çš„è®°å¿†å­—ç¬¦ä¸²æ•°ç»„
 */
async function multiQueryRAG(
  supabase: ReturnType<typeof createClient>,
  userId: string,
  questions: string[],
  limit: number = 10
): Promise<string[]> {
  try {
    console.log(`ğŸ” Multi-Query RAG: ${questions.length} questions`);

    // 1. å¹¶è¡Œç”Ÿæˆæ‰€æœ‰é—®é¢˜çš„ embeddings
    const startEmbed = Date.now();
    const embeddings = await generateEmbeddings(questions);
    console.log(`â±ï¸ Embedding generation: ${Date.now() - startEmbed}ms`);

    // 2. è°ƒç”¨ multi_query_search_memories RPC
    const embeddingsJson = embeddings.map(e => JSON.stringify(e));

    const startSearch = Date.now();
    const { data, error } = await supabase.rpc('multi_query_search_memories', {
      p_user_id: userId,
      p_embeddings: embeddingsJson,
      p_threshold: 0.6, // æ¯”å•æŸ¥è¯¢æ›´å®½æ¾çš„é˜ˆå€¼
      p_limit_per_query: 5,
    });
    console.log(`â±ï¸ Vector search: ${Date.now() - startSearch}ms`);

    if (error) {
      console.error('Multi-query search failed:', error);
      return [];
    }

    // 3. MRR èåˆ
    const startMRR = Date.now();
    const fusedResults = mergeWithMRR(data || []);
    console.log(`â±ï¸ MRR fusion: ${Date.now() - startMRR}ms`);
    console.log(`ğŸ“Š MRR fusion: ${fusedResults.length} unique memories`);

    // 4. æ ¼å¼åŒ–è¿”å›
    const tagContext: Record<string, string> = {
      'PREF': '(AI äº¤äº’åå¥½)',
      'PROC': '(æ‹–å»¶æ¨¡å¼)',
      'SOMA': '(èº«å¿ƒååº”)',
      'EMO': '(æƒ…ç»ªæ¨¡å¼)',
      'SAB': '(è‡ªæˆ‘å¦¨ç¢)',
      'EFFECTIVE': '(æœ‰æ•ˆæ¿€åŠ±æ–¹å¼)',
    };

    return fusedResults.slice(0, limit).map(m => {
      const context = tagContext[m.tag] || '';
      return `${m.content} ${context}`.trim();
    });
  } catch (error) {
    console.error('Multi-Query RAG error:', error);
    return [];
  }
}
```

#### é‡æ„ getUserMemories å‡½æ•°

```typescript
/**
 * è·å–ç”¨æˆ·è®°å¿† - Tolan å‡çº§ç‰ˆ
 *
 * æµç¨‹:
 * 1. å§‹ç»ˆåŠ è½½ PREF + EFFECTIVE è®°å¿†
 * 2. Question Synthesis: ç”Ÿæˆæ£€ç´¢é—®é¢˜
 * 3. Multi-Query RAG: å¹¶è¡Œå‘é‡æœç´¢
 * 4. MRR Fusion: èåˆæ’åºç»“æœ
 */
async function getUserMemories(
  supabase: ReturnType<typeof createClient>,
  userId: string,
  taskDescription: string,
  limit = 10
): Promise<string[]> {
  const ENABLE_TOLAN = Deno.env.get('ENABLE_TOLAN_MEMORY') === 'true';

  // å¦‚æœæœªå¯ç”¨ Tolanï¼Œä½¿ç”¨åŸæœ‰é€»è¾‘
  if (!ENABLE_TOLAN) {
    return await getUserMemoriesLegacy(supabase, userId, taskDescription, limit);
  }

  try {
    const memories: string[] = [];
    const startTotal = Date.now();

    // ==========================================
    // Phase 0: å§‹ç»ˆåŠ è½½çš„è®°å¿† (PREF + EFFECTIVE)
    // ==========================================

    // PREF å…¨é‡åŠ è½½ï¼ˆä¸é™æ¡æ•°ï¼‰
    const { data: prefMemories } = await supabase
      .from('user_memories')
      .select('content, tag')
      .eq('user_id', userId)
      .eq('tag', 'PREF')
      .eq('compression_status', 'active')
      .gte('confidence', 0.5)
      .order('importance_score', { ascending: false });

    if (prefMemories) {
      memories.push(...prefMemories.map(m => `${m.content} (AI äº¤äº’åå¥½)`));
      console.log(`ğŸ§  PREF memories: ${prefMemories.length}`);
    }

    // EFFECTIVE æœ€å¤š 5 æ¡
    const { data: effectiveMemories } = await supabase
      .from('user_memories')
      .select('content, tag')
      .eq('user_id', userId)
      .eq('tag', 'EFFECTIVE')
      .eq('compression_status', 'active')
      .gte('confidence', 0.5)
      .order('importance_score', { ascending: false })
      .limit(5);

    if (effectiveMemories) {
      memories.push(...effectiveMemories.map(m => `${m.content} (æœ‰æ•ˆæ¿€åŠ±æ–¹å¼)`));
      console.log(`ğŸ§  EFFECTIVE memories: ${effectiveMemories.length}`);
    }

    // ==========================================
    // Phase 1: Question Synthesis
    // ==========================================
    const questions = await synthesizeQuestions(taskDescription);
    console.log(`ğŸ” Synthesized questions: ${questions.length}`);

    // ==========================================
    // Phase 2-4: Multi-Query RAG + MRR Fusion
    // ==========================================
    const ragLimit = Math.max(1, limit - memories.length);
    const ragMemories = await multiQueryRAG(supabase, userId, questions, ragLimit);

    // å»é‡ï¼ˆé¿å…å’Œ PREF/EFFECTIVE é‡å¤ï¼‰
    const existingContents = new Set(memories.map(m => m.split(' (')[0]));
    const uniqueRagMemories = ragMemories.filter(m =>
      !existingContents.has(m.split(' (')[0])
    );

    memories.push(...uniqueRagMemories);

    console.log(`ğŸ§  Final memories: ${memories.length}`);
    console.log(`â±ï¸ Total retrieval time: ${Date.now() - startTotal}ms`);

    return memories.slice(0, limit);
  } catch (error) {
    console.warn('Tolan retrieval failed, falling back to legacy:', error);
    return await getUserMemoriesLegacy(supabase, userId, taskDescription, limit);
  }
}

// ä¿ç•™åŸæœ‰å‡½æ•°ä½œä¸ºé™çº§æ–¹æ¡ˆ
async function getUserMemoriesLegacy(
  supabase: ReturnType<typeof createClient>,
  userId: string,
  taskDescription: string,
  limit = 10
): Promise<string[]> {
  // ... åŸæœ‰çš„ textSearch é€»è¾‘
}
```

### 5.2 æ–°å»º: memory-compressor/index.ts

å®Œæ•´ä»£ç è§ [é™„å½• 10.2](#102-memory-compressorindexts-å®Œæ•´ä»£ç )

#### æ ¸å¿ƒå‡½æ•°æ¸…å•

| å‡½æ•°å | åŠŸèƒ½ |
|--------|------|
| `evaluateImportance()` | ä½¿ç”¨ AI è¯„ä¼°è®°å¿†é‡è¦æ€§ (0-1) |
| `resolveContradictions()` | æ£€æµ‹å¹¶è§£å†³çŸ›ç›¾è®°å¿† |
| `compressLowValueMemories()` | æ¸…ç†ä½ä»·å€¼è®°å¿† |
| `mergeRedundantMemories()` | åˆå¹¶é‡å¤è®°å¿† |

#### API æ¥å£

**è¯·æ±‚æ ¼å¼:**

```json
// å‹ç¼©æ‰€æœ‰ç”¨æˆ·ï¼ˆç”± cron è°ƒç”¨ï¼‰
{
  "action": "compress_all"
}

// å‹ç¼©å•ä¸ªç”¨æˆ·
{
  "action": "compress_user",
  "userId": "xxx-xxx-xxx"
}

// åªè¯„ä¼°ä¸æ‰§è¡Œï¼ˆè°ƒè¯•ç”¨ï¼‰
{
  "action": "dry_run",
  "userId": "xxx-xxx-xxx"
}
```

**å“åº”æ ¼å¼:**

```json
{
  "success": true,
  "usersProcessed": 150,
  "totalEvaluated": 2340,
  "totalDeleted": 234,
  "totalCompressed": 456,
  "contradictionsResolved": 23,
  "mergedGroups": 89,
  "durationMs": 45000
}
```

### 5.3 ä¿®æ”¹: memory-extractor/index.ts

#### æ·»åŠ é‡è¦æ€§è¯„åˆ†

åœ¨ `saveOrMergeMemories` å‡½æ•°ä¸­ï¼Œä¸ºæ–°è®°å¿†è®¡ç®—åˆå§‹é‡è¦æ€§è¯„åˆ†ï¼š

```typescript
// åœ¨æ’å…¥æ–°è®°å¿†æ—¶æ·»åŠ  importance_score
const { data: newMemory, error: insertError } = await supabase
  .from('user_memories')
  .insert({
    user_id: userId,
    content: memory.content,
    tag: memory.tag,
    confidence: memory.confidence,
    embedding: embedding,
    task_name: taskDescription || null,
    // æ–°å¢ï¼šæ ¹æ®ç½®ä¿¡åº¦å’Œæ ‡ç­¾è®¡ç®—åˆå§‹é‡è¦æ€§
    importance_score: calculateInitialImportance(memory),
  })
  .select()
  .single();

// æ–°å¢å‡½æ•°
function calculateInitialImportance(memory: ExtractedMemory): number {
  let score = memory.confidence; // åŸºç¡€åˆ† = ç½®ä¿¡åº¦

  // PREF å’Œ EFFECTIVE ç±»å‹åŠ åˆ†
  if (memory.tag === 'PREF' || memory.tag === 'EFFECTIVE') {
    score = Math.min(1, score + 0.2);
  }

  return score;
}
```

---

## 6. æ€§èƒ½ä¼˜åŒ–

### 6.1 å»¶è¿Ÿé¢„ç®—

| æ­¥éª¤ | å½“å‰å»¶è¿Ÿ | ä¼˜åŒ–åç›®æ ‡ | ä¼˜åŒ–æ–¹æ³• |
|------|---------|-----------|---------|
| Question Synthesis | æ–°å¢ | ~300ms | ä½æ¸©åº¦ + çŸ­ max_tokens |
| Embedding Generation | NÃ—200ms | ~200ms | æ‰¹é‡ API (å•æ¬¡è¯·æ±‚å¤šä¸ª input) |
| Multi-Query Search | NÃ—100ms | ~150ms | å¹¶è¡Œ RPC + æ•°æ®åº“è¿æ¥æ±  |
| MRR Fusion | - | ~5ms | å†…å­˜ä¸­è®¡ç®—ï¼Œæ—  IO |
| **æ€»è®¡** | - | **~650ms** | - |

### 6.2 ç¼“å­˜ç­–ç•¥

```typescript
// ç®€å•çš„å†…å­˜ç¼“å­˜
const memoryCache = new Map<string, {
  data: string[];
  expires: number
}>();

const CACHE_TTL_MS = 5 * 60 * 1000; // 5 åˆ†é’Ÿ

async function getUserMemoriesWithCache(
  supabase: ReturnType<typeof createClient>,
  userId: string,
  taskDescription: string
): Promise<string[]> {
  const cacheKey = `${userId}:${taskDescription}`;
  const cached = memoryCache.get(cacheKey);

  if (cached && cached.expires > Date.now()) {
    console.log('ğŸš€ Memory cache hit');
    return cached.data;
  }

  const memories = await getUserMemories(supabase, userId, taskDescription);

  memoryCache.set(cacheKey, {
    data: memories,
    expires: Date.now() + CACHE_TTL_MS,
  });

  return memories;
}
```

### 6.3 é™çº§ç­–ç•¥

```typescript
const ENABLE_TOLAN = Deno.env.get('ENABLE_TOLAN_MEMORY') === 'true';

async function getUserMemoriesWithFallback(
  supabase: ReturnType<typeof createClient>,
  userId: string,
  taskDescription: string,
  limit: number
): Promise<string[]> {
  if (!ENABLE_TOLAN) {
    return await getUserMemoriesLegacy(supabase, userId, taskDescription, limit);
  }

  try {
    return await getUserMemories(supabase, userId, taskDescription, limit);
  } catch (error) {
    console.warn('Tolan retrieval failed, falling back to simple search:', error);
    return await getUserMemoriesLegacy(supabase, userId, taskDescription, limit);
  }
}
```

---

## 7. éƒ¨ç½²é…ç½®

### 7.1 ç¯å¢ƒå˜é‡

```bash
# åŠŸèƒ½å¼€å…³
ENABLE_TOLAN_MEMORY=true

# Azure OpenAI (å·²æœ‰)
AZURE_AI_ENDPOINT=https://your-endpoint.openai.azure.com
AZURE_AI_API_KEY=your-api-key
MEMORY_EXTRACTOR_MODEL=gpt-5.1-chat

# Embedding (å·²æœ‰)
AZURE_EMBEDDING_ENDPOINT=https://your-embedding-endpoint.openai.azure.com
AZURE_EMBEDDING_API_KEY=your-embedding-api-key
MEMORY_EMBEDDING_MODEL=text-embedding-3-large

# å¤œé—´å‹ç¼©é…ç½®
COMPRESSION_LOW_IMPORTANCE_THRESHOLD=0.3
COMPRESSION_MIN_AGE_DAYS=7
```

### 7.2 æ•°æ®åº“è¿ç§»å‘½ä»¤

```bash
# åº”ç”¨è¿ç§»
supabase db push

# æˆ–æ‰‹åŠ¨æ‰§è¡Œ
psql -h <host> -U postgres -d postgres -f supabase/migrations/20260127100000_tolan_memory_system.sql
psql -h <host> -U postgres -d postgres -f supabase/migrations/20260127110000_memory_compression_cron.sql
```

### 7.3 éƒ¨ç½² Edge Functions

```bash
# éƒ¨ç½²ä¿®æ”¹çš„å‡½æ•°
supabase functions deploy get-system-instruction
supabase functions deploy memory-extractor

# éƒ¨ç½²æ–°å‡½æ•°
supabase functions deploy memory-compressor
```

### 7.4 éªŒè¯ Cron ä»»åŠ¡

```sql
-- æŸ¥çœ‹å·²æ³¨å†Œçš„ cron ä»»åŠ¡
SELECT * FROM cron.job;

-- æ‰‹åŠ¨è§¦å‘ä¸€æ¬¡ï¼ˆæµ‹è¯•ç”¨ï¼‰
SELECT cron.schedule('test_compression', 'now',
  $$ SELECT net.http_post(...) $$
);

-- å–æ¶ˆæµ‹è¯•ä»»åŠ¡
SELECT cron.unschedule('test_compression');
```

---

## 8. éªŒè¯è®¡åˆ’

### 8.1 Phase 1 éªŒæ”¶æ ‡å‡†

| éªŒæ”¶é¡¹ | æ ‡å‡† | éªŒè¯æ–¹æ³• |
|--------|------|---------|
| é—®é¢˜åˆæˆ | èƒ½ç”Ÿæˆ 3-5 ä¸ªæœ‰æ„ä¹‰çš„é—®é¢˜ | æŸ¥çœ‹æ—¥å¿—è¾“å‡º |
| å¤šæŸ¥è¯¢æœç´¢ | æ¯ä¸ªé—®é¢˜è¿”å› â‰¤5 æ¡ç»“æœ | æŸ¥çœ‹ RPC è¿”å› |
| MRR èåˆ | ç»“æœæŒ‰åˆ†æ•°æ­£ç¡®æ’åº | å•å…ƒæµ‹è¯• |
| ç«¯åˆ°ç«¯å»¶è¿Ÿ | < 1000ms | æ—¥å¿—è®¡æ—¶ |
| å›å½’æµ‹è¯• | åŸæœ‰åŠŸèƒ½ä¸å—å½±å“ | æ‰‹åŠ¨æµ‹è¯• |

### 8.2 Phase 2 éªŒæ”¶æ ‡å‡†

| éªŒæ”¶é¡¹ | æ ‡å‡† | éªŒè¯æ–¹æ³• |
|--------|------|---------|
| Cron ä»»åŠ¡ | æ¯å¤© 3:00 UTC è‡ªåŠ¨æ‰§è¡Œ | æŸ¥çœ‹ cron.job_run_details |
| é‡è¦æ€§è¯„åˆ† | æ­£ç¡®è¯†åˆ«ä½ä»·å€¼è®°å¿† | æŠ½æ ·æ£€æŸ¥ |
| çŸ›ç›¾è§£å†³ | ä¿ç•™æœ€æ–°ç‰ˆæœ¬ | æŸ¥çœ‹ superseded_by å­—æ®µ |
| åˆå¹¶é‡å¤ | merged_from è®°å½•æ­£ç¡® | æŸ¥çœ‹ metadata |

### 8.3 æµ‹è¯•ç”¨ä¾‹

```typescript
// æµ‹è¯• Question Synthesis
const questions = await synthesizeQuestions("æˆ‘å‘¨æœ«è¦å»æ—…è¡Œ");
assert(questions.length >= 3 && questions.length <= 5);
assert(questions.every(q => q.includes("ç”¨æˆ·") || q.includes("user")));

// æµ‹è¯• MRR Fusion
const mockResults = [
  { query_index: 1, memory_id: 'A', rank: 1, ... },
  { query_index: 1, memory_id: 'B', rank: 2, ... },
  { query_index: 2, memory_id: 'B', rank: 1, ... },
  { query_index: 2, memory_id: 'A', rank: 3, ... },
];
const fused = mergeWithMRR(mockResults);
assert(fused[0].memory_id === 'B'); // B å¾—åˆ†æœ€é«˜: 0.5 + 1 = 1.5
assert(fused[1].memory_id === 'A'); // A å¾—åˆ†: 1 + 0.33 = 1.33
```

---

## 9. å›æ»šç­–ç•¥

### 9.1 å³æ—¶å›æ»šï¼ˆåŠŸèƒ½å¼€å…³ï¼‰

```bash
# ç¦ç”¨ Tolan åŠŸèƒ½ï¼Œç«‹å³å›é€€åˆ°åŸæœ‰é€»è¾‘
ENABLE_TOLAN_MEMORY=false
```

### 9.2 æš‚åœ Cron ä»»åŠ¡

```sql
-- æš‚åœå¤œé—´å‹ç¼©
SELECT cron.unschedule('memory_nightly_compression');

-- æ¢å¤
SELECT cron.schedule('memory_nightly_compression', '0 3 * * *', ...);
```

### 9.3 æ•°æ®åº“å›æ»š

æ–°å¢çš„å­—æ®µä¸å½±å“åŸæœ‰ä»£ç ï¼Œæ— éœ€å›æ»šã€‚å¦‚æœç¡®å®éœ€è¦ï¼š

```sql
-- æ¢å¤è¢«å‹ç¼©çš„è®°å¿†
UPDATE user_memories
SET compression_status = 'active'
WHERE compression_status = 'compressed';

-- åˆ é™¤æ–°å­—æ®µï¼ˆè°¨æ…ï¼ï¼‰
ALTER TABLE user_memories DROP COLUMN importance_score;
ALTER TABLE user_memories DROP COLUMN version;
ALTER TABLE user_memories DROP COLUMN superseded_by;
ALTER TABLE user_memories DROP COLUMN compression_status;
```

---

## 10. é™„å½•ï¼šå®Œæ•´ä»£ç 

### 10.1 æ•°æ®åº“è¿ç§»å®Œæ•´ SQL

**æ–‡ä»¶: `supabase/migrations/20260127100000_tolan_memory_system.sql`**

```sql
-- =====================================================
-- Tolan Memory System Upgrade
-- åŠŸèƒ½: é—®é¢˜åˆæˆã€å¤šæŸ¥è¯¢ RAGã€MRR èåˆã€å¤œé—´å‹ç¼©
-- åˆ›å»ºæ—¥æœŸ: 2026-01-27
-- =====================================================

-- 1. æ‰©å±• user_memories è¡¨
-- =====================================================

-- é‡è¦æ€§è¯„åˆ† (0-1)
ALTER TABLE user_memories
  ADD COLUMN IF NOT EXISTS importance_score FLOAT DEFAULT 0.5;

-- ç‰ˆæœ¬å· (çŸ›ç›¾è§£å†³æ—¶é€’å¢)
ALTER TABLE user_memories
  ADD COLUMN IF NOT EXISTS version INTEGER DEFAULT 1;

-- è¢«æ›¿ä»£çš„æ–°è®°å¿† ID
ALTER TABLE user_memories
  ADD COLUMN IF NOT EXISTS superseded_by UUID REFERENCES user_memories(id);

-- å‹ç¼©çŠ¶æ€
ALTER TABLE user_memories
  ADD COLUMN IF NOT EXISTS compression_status TEXT DEFAULT 'active';

-- æ·»åŠ çº¦æŸ
DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM pg_constraint WHERE conname = 'user_memories_compression_status_check'
  ) THEN
    ALTER TABLE user_memories
      ADD CONSTRAINT user_memories_compression_status_check
      CHECK (compression_status IN ('active', 'compressed', 'deleted'));
  END IF;
END $$;

-- æ·»åŠ å­—æ®µæ³¨é‡Š
COMMENT ON COLUMN user_memories.importance_score IS 'è®°å¿†é‡è¦æ€§è¯„åˆ† 0-1ï¼Œç”± AI è¯„ä¼°ï¼Œç”¨äºå‹ç¼©å†³ç­–';
COMMENT ON COLUMN user_memories.version IS 'è®°å¿†ç‰ˆæœ¬å·ï¼ŒçŸ›ç›¾è§£å†³æ—¶é€’å¢ï¼Œç”¨äºä¿ç•™å†å²';
COMMENT ON COLUMN user_memories.superseded_by IS 'è¢«å“ªæ¡æ–°è®°å¿†æ›¿ä»£ï¼ˆçŸ›ç›¾è§£å†³æ—¶è®¾ç½®ï¼‰';
COMMENT ON COLUMN user_memories.compression_status IS 'å‹ç¼©çŠ¶æ€: active=æ´»è·ƒ, compressed=å·²å‹ç¼©, deleted=å·²åˆ é™¤';

-- 2. åˆ›å»ºç´¢å¼•
-- =====================================================

-- æŒ‰é‡è¦æ€§æ’åºçš„ç´¢å¼•ï¼ˆåªç´¢å¼•æ´»è·ƒè®°å¿†ï¼‰
CREATE INDEX IF NOT EXISTS idx_user_memories_importance
  ON user_memories(user_id, importance_score DESC)
  WHERE compression_status = 'active';

-- å‹ç¼©ä»»åŠ¡ä¸“ç”¨ç´¢å¼•
CREATE INDEX IF NOT EXISTS idx_user_memories_compression
  ON user_memories(compression_status, updated_at)
  WHERE compression_status = 'active';

-- 3. å¤šæŸ¥è¯¢å‘é‡æœç´¢å‡½æ•°
-- =====================================================

CREATE OR REPLACE FUNCTION multi_query_search_memories(
  p_user_id UUID,
  p_embeddings TEXT[],  -- JSON æ ¼å¼çš„ embedding æ•°ç»„
  p_threshold FLOAT DEFAULT 0.6,
  p_limit_per_query INTEGER DEFAULT 5
)
RETURNS TABLE (
  query_index INTEGER,
  memory_id UUID,
  content TEXT,
  tag TEXT,
  confidence FLOAT,
  importance_score FLOAT,
  similarity FLOAT,
  rank INTEGER
)
LANGUAGE plpgsql
AS $$
DECLARE
  v_embedding_json TEXT;
  v_embedding vector(1536);
  v_query_index INTEGER := 0;
BEGIN
  -- éå†æ¯ä¸ª embedding
  FOREACH v_embedding_json IN ARRAY p_embeddings
  LOOP
    v_query_index := v_query_index + 1;

    -- å°† JSON å­—ç¬¦ä¸²è½¬æ¢ä¸º vector
    v_embedding := v_embedding_json::vector(1536);

    -- æ‰§è¡Œå‘é‡æœç´¢å¹¶è¿”å›ç»“æœ
    RETURN QUERY
    WITH ranked AS (
      SELECT
        m.id AS memory_id,
        m.content,
        m.tag,
        m.confidence,
        COALESCE(m.importance_score, 0.5) AS importance_score,
        1 - (m.embedding <=> v_embedding) AS similarity,
        ROW_NUMBER() OVER (
          ORDER BY (1 - (m.embedding <=> v_embedding)) DESC
        )::INTEGER AS rank
      FROM user_memories m
      WHERE m.user_id = p_user_id
        AND m.embedding IS NOT NULL
        AND (m.compression_status IS NULL OR m.compression_status = 'active')
        AND (1 - (m.embedding <=> v_embedding)) >= p_threshold
      LIMIT p_limit_per_query
    )
    SELECT v_query_index, ranked.* FROM ranked;
  END LOOP;
END;
$$;

COMMENT ON FUNCTION multi_query_search_memories IS
  'å¤šæŸ¥è¯¢å‘é‡æœç´¢ï¼Œæ”¯æŒæ‰¹é‡ embedding å¹¶è¡Œæœç´¢ï¼Œè¿”å›å¸¦æ’åçš„ç»“æœç”¨äº MRR èåˆ';

-- 4. è·å–å‹ç¼©å€™é€‰è®°å¿†å‡½æ•°
-- =====================================================

CREATE OR REPLACE FUNCTION get_compression_candidates(
  p_user_id UUID,
  p_min_age_days INTEGER DEFAULT 7,
  p_low_importance_threshold FLOAT DEFAULT 0.3,
  p_limit INTEGER DEFAULT 100
)
RETURNS TABLE (
  id UUID,
  content TEXT,
  tag TEXT,
  importance_score FLOAT,
  access_count INTEGER,
  created_at TIMESTAMPTZ,
  reason TEXT
)
LANGUAGE plpgsql
AS $$
BEGIN
  RETURN QUERY
  SELECT
    m.id,
    m.content,
    m.tag,
    COALESCE(m.importance_score, 0.5) AS importance_score,
    COALESCE(m.access_count, 0) AS access_count,
    m.created_at,
    CASE
      WHEN COALESCE(m.importance_score, 0.5) < p_low_importance_threshold
        THEN 'low_importance'
      WHEN COALESCE(m.access_count, 0) = 0
        AND m.created_at < NOW() - (p_min_age_days || ' days')::INTERVAL
        THEN 'never_accessed'
      ELSE 'other'
    END AS reason
  FROM user_memories m
  WHERE m.user_id = p_user_id
    AND (m.compression_status IS NULL OR m.compression_status = 'active')
    AND (
      -- ä½é‡è¦æ€§è®°å¿†
      COALESCE(m.importance_score, 0.5) < p_low_importance_threshold
      -- æˆ–ï¼šä»æœªè¢«è®¿é—®ä¸”è¶…è¿‡ N å¤©
      OR (
        COALESCE(m.access_count, 0) = 0
        AND m.created_at < NOW() - (p_min_age_days || ' days')::INTERVAL
      )
    )
  ORDER BY COALESCE(m.importance_score, 0.5) ASC, COALESCE(m.access_count, 0) ASC
  LIMIT p_limit;
END;
$$;

COMMENT ON FUNCTION get_compression_candidates IS
  'è·å–å¾…å‹ç¼©çš„ä½ä»·å€¼è®°å¿†å€™é€‰ï¼ŒåŸºäºé‡è¦æ€§è¯„åˆ†å’Œè®¿é—®é¢‘ç‡';

-- 5. æ ‡è®°è®°å¿†ä¸ºå·²å‹ç¼©å‡½æ•°
-- =====================================================

CREATE OR REPLACE FUNCTION mark_memories_compressed(
  p_memory_ids UUID[],
  p_action TEXT DEFAULT 'compress'  -- 'compress' æˆ– 'delete'
)
RETURNS INTEGER
LANGUAGE plpgsql
AS $$
DECLARE
  v_count INTEGER;
BEGIN
  IF p_action = 'delete' THEN
    -- æ°¸ä¹…åˆ é™¤
    DELETE FROM user_memories WHERE id = ANY(p_memory_ids);
  ELSE
    -- è½¯åˆ é™¤ï¼ˆæ ‡è®°ä¸ºå·²å‹ç¼©ï¼‰
    UPDATE user_memories
    SET
      compression_status = 'compressed',
      updated_at = NOW()
    WHERE id = ANY(p_memory_ids);
  END IF;

  GET DIAGNOSTICS v_count = ROW_COUNT;
  RETURN v_count;
END;
$$;

COMMENT ON FUNCTION mark_memories_compressed IS
  'æ‰¹é‡æ ‡è®°è®°å¿†ä¸ºå·²å‹ç¼©æˆ–æ°¸ä¹…åˆ é™¤';

-- 6. è·å–ç”¨æˆ·æ‰€æœ‰æ´»è·ƒè®°å¿†ï¼ˆæŒ‰æ ‡ç­¾åˆ†ç»„ï¼‰
-- =====================================================

CREATE OR REPLACE FUNCTION get_user_memories_by_tag(
  p_user_id UUID,
  p_tag TEXT DEFAULT NULL
)
RETURNS TABLE (
  id UUID,
  content TEXT,
  tag TEXT,
  confidence FLOAT,
  importance_score FLOAT,
  created_at TIMESTAMPTZ
)
LANGUAGE plpgsql
AS $$
BEGIN
  RETURN QUERY
  SELECT
    m.id,
    m.content,
    m.tag,
    m.confidence,
    COALESCE(m.importance_score, 0.5) AS importance_score,
    m.created_at
  FROM user_memories m
  WHERE m.user_id = p_user_id
    AND (m.compression_status IS NULL OR m.compression_status = 'active')
    AND (p_tag IS NULL OR m.tag = p_tag)
  ORDER BY m.created_at DESC;
END;
$$;

COMMENT ON FUNCTION get_user_memories_by_tag IS
  'è·å–ç”¨æˆ·æ‰€æœ‰æ´»è·ƒè®°å¿†ï¼Œå¯æŒ‰æ ‡ç­¾ç­›é€‰';
```

**æ–‡ä»¶: `supabase/migrations/20260127110000_memory_compression_cron.sql`**

```sql
-- =====================================================
-- Memory Compression Cron Job
-- æ¯å¤©å‡Œæ™¨ 3:00 UTC æ‰§è¡Œå¤œé—´å‹ç¼©
-- =====================================================

-- å¯ç”¨ pg_cron æ‰©å±•ï¼ˆå¦‚æœå°šæœªå¯ç”¨ï¼‰
CREATE EXTENSION IF NOT EXISTS pg_cron;

-- å¯ç”¨ pg_net æ‰©å±•ï¼ˆç”¨äº HTTP è°ƒç”¨ï¼‰
CREATE EXTENSION IF NOT EXISTS pg_net;

-- åˆ›å»ºå¤œé—´å‹ç¼©ä»»åŠ¡
-- æ³¨æ„ï¼šéœ€è¦å…ˆè®¾ç½® app.settings.supabase_url å’Œ app.settings.service_role_key
SELECT cron.schedule(
  'memory_nightly_compression',  -- ä»»åŠ¡åç§°
  '0 3 * * *',                   -- Cron è¡¨è¾¾å¼ï¼šæ¯å¤© 3:00 UTC
  $$
  SELECT net.http_post(
    url := current_setting('app.settings.supabase_url') || '/functions/v1/memory-compressor',
    headers := jsonb_build_object(
      'Content-Type', 'application/json',
      'Authorization', 'Bearer ' || current_setting('app.settings.service_role_key')
    ),
    body := '{"action": "compress_all"}'::jsonb
  );
  $$
);

-- æŸ¥çœ‹å·²æ³¨å†Œçš„ä»»åŠ¡
-- SELECT * FROM cron.job;

-- æŸ¥çœ‹ä»»åŠ¡æ‰§è¡Œå†å²
-- SELECT * FROM cron.job_run_details ORDER BY start_time DESC LIMIT 10;

-- å¦‚éœ€å–æ¶ˆä»»åŠ¡
-- SELECT cron.unschedule('memory_nightly_compression');
```

### 10.2 memory-compressor/index.ts å®Œæ•´ä»£ç 

```typescript
import { serve } from "https://deno.land/std@0.168.0/http/server.ts"
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2'

const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
}

// é…ç½®
const AZURE_ENDPOINT = Deno.env.get('AZURE_AI_ENDPOINT');
const AZURE_API_KEY = Deno.env.get('AZURE_AI_API_KEY');
const MODEL_NAME = Deno.env.get('MEMORY_EXTRACTOR_MODEL') || 'gpt-5.1-chat';
const LOW_IMPORTANCE_THRESHOLD = parseFloat(
  Deno.env.get('COMPRESSION_LOW_IMPORTANCE_THRESHOLD') || '0.3'
);
const MIN_AGE_DAYS = parseInt(
  Deno.env.get('COMPRESSION_MIN_AGE_DAYS') || '7'
);

interface Memory {
  id: string;
  content: string;
  tag: string;
  confidence?: number;
  importance_score?: number;
  access_count?: number;
  created_at?: string;
}

interface CompressionResult {
  evaluated: number;
  deleted: number;
  compressed: number;
  contradictionsResolved: number;
  mergedGroups: number;
}

/**
 * ä½¿ç”¨ AI è¯„ä¼°è®°å¿†çš„é‡è¦æ€§
 */
async function evaluateImportance(
  memories: Memory[]
): Promise<Map<string, number>> {
  if (!AZURE_API_KEY || memories.length === 0) {
    return new Map(memories.map(m => [m.id, 0.5]));
  }

  const prompt = `You are a memory importance evaluator. Rate each memory's importance for understanding a user's behavior patterns and preferences.

Memories to evaluate:
${memories.map((m, i) => `${i + 1}. [${m.tag}] ${m.content}`).join('\n')}

For each memory, rate its importance from 0.0 to 1.0:
- 0.0-0.2: Trivial, ephemeral (e.g., "user drank coffee today", "user said hi")
- 0.3-0.5: Somewhat useful context (e.g., "user was tired today")
- 0.6-0.8: Important pattern or preference (e.g., "user prefers morning workouts")
- 0.9-1.0: Core insight about user behavior (e.g., "user procrastinates when overwhelmed")

Return ONLY a JSON array of numbers in the same order as the memories.
Example: [0.3, 0.8, 0.5, 0.9]`;

  try {
    const response = await fetch(`${AZURE_ENDPOINT}/openai/v1/chat/completions`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${AZURE_API_KEY}`,
      },
      body: JSON.stringify({
        model: MODEL_NAME,
        messages: [{ role: 'user', content: prompt }],
        max_completion_tokens: 200,
        temperature: 0.1,
      }),
    });

    if (!response.ok) {
      console.error('Importance evaluation API failed:', response.status);
      return new Map(memories.map(m => [m.id, 0.5]));
    }

    const result = await response.json();
    const content = result.choices?.[0]?.message?.content || '[]';

    // å°è¯•è§£æ JSON
    let scores: number[];
    try {
      scores = JSON.parse(content.trim());
    } catch {
      // å°è¯•ä»æ–‡æœ¬ä¸­æå–æ•°å­—
      const matches = content.match(/[\d.]+/g);
      scores = matches ? matches.map(Number) : [];
    }

    const scoreMap = new Map<string, number>();
    memories.forEach((m, i) => {
      const score = scores[i];
      scoreMap.set(m.id, (typeof score === 'number' && !isNaN(score)) ? score : 0.5);
    });

    return scoreMap;
  } catch (error) {
    console.error('Importance evaluation failed:', error);
    return new Map(memories.map(m => [m.id, 0.5]));
  }
}

/**
 * æ£€æµ‹å¹¶è§£å†³çŸ›ç›¾è®°å¿†
 */
async function resolveContradictions(
  supabase: ReturnType<typeof createClient>,
  userId: string
): Promise<number> {
  // è·å–æ´»è·ƒè®°å¿†
  const { data: memories, error } = await supabase
    .from('user_memories')
    .select('id, content, tag, created_at, version')
    .eq('user_id', userId)
    .eq('compression_status', 'active')
    .order('created_at', { ascending: false });

  if (error || !memories || memories.length < 2) {
    return 0;
  }

  // æŒ‰ tag åˆ†ç»„
  const byTag = new Map<string, typeof memories>();
  for (const m of memories) {
    if (!byTag.has(m.tag)) byTag.set(m.tag, []);
    byTag.get(m.tag)!.push(m);
  }

  let resolved = 0;

  for (const [tag, tagMemories] of byTag) {
    if (tagMemories.length < 2) continue;

    // ä½¿ç”¨ AI æ£€æµ‹çŸ›ç›¾
    const prompt = `Check if any of these memories about the same topic contradict each other.

Memories (${tag}):
${tagMemories.slice(0, 10).map((m, i) => `${i + 1}. ${m.content}`).join('\n')}

If there are contradictions (e.g., opposite preferences, changed facts), return:
{
  "hasContradiction": true,
  "pairs": [[olderIndex, newerIndex], ...]
}

Where olderIndex is the index of the OLDER (outdated) memory and newerIndex is the NEWER (current) one.
Memories with higher index numbers are more recent.

If no contradictions found:
{"hasContradiction": false}

Return ONLY the JSON object.`;

    try {
      const response = await fetch(`${AZURE_ENDPOINT}/openai/v1/chat/completions`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${AZURE_API_KEY}`,
        },
        body: JSON.stringify({
          model: MODEL_NAME,
          messages: [{ role: 'user', content: prompt }],
          max_completion_tokens: 300,
          temperature: 0.1,
        }),
      });

      if (!response.ok) continue;

      const result = await response.json();
      const content = result.choices?.[0]?.message?.content || '{}';

      let analysis;
      try {
        analysis = JSON.parse(content.trim());
      } catch {
        continue;
      }

      if (analysis.hasContradiction && Array.isArray(analysis.pairs)) {
        for (const pair of analysis.pairs) {
          if (!Array.isArray(pair) || pair.length !== 2) continue;

          const [oldIdx, newIdx] = pair;
          if (oldIdx < 1 || oldIdx > tagMemories.length) continue;
          if (newIdx < 1 || newIdx > tagMemories.length) continue;

          const oldMemory = tagMemories[oldIdx - 1];
          const newMemory = tagMemories[newIdx - 1];

          // æ ‡è®°æ—§è®°å¿†è¢«æ›¿ä»£
          await supabase
            .from('user_memories')
            .update({
              superseded_by: newMemory.id,
              compression_status: 'compressed',
              updated_at: new Date().toISOString(),
            })
            .eq('id', oldMemory.id);

          // å¢åŠ æ–°è®°å¿†çš„ç‰ˆæœ¬å·
          await supabase
            .from('user_memories')
            .update({
              version: (newMemory.version || 1) + 1,
              updated_at: new Date().toISOString(),
            })
            .eq('id', newMemory.id);

          resolved++;
          console.log(`ğŸ”„ Resolved contradiction: "${oldMemory.content}" â†’ "${newMemory.content}"`);
        }
      }
    } catch (error) {
      console.error(`Contradiction check failed for tag ${tag}:`, error);
    }
  }

  return resolved;
}

/**
 * å‹ç¼©ä½ä»·å€¼è®°å¿†
 */
async function compressLowValueMemories(
  supabase: ReturnType<typeof createClient>,
  userId: string
): Promise<{ evaluated: number; deleted: number; compressed: number }> {
  // è·å–å‹ç¼©å€™é€‰
  const { data: candidates, error } = await supabase.rpc('get_compression_candidates', {
    p_user_id: userId,
    p_min_age_days: MIN_AGE_DAYS,
    p_low_importance_threshold: LOW_IMPORTANCE_THRESHOLD,
    p_limit: 50,
  });

  if (error || !candidates || candidates.length === 0) {
    return { evaluated: 0, deleted: 0, compressed: 0 };
  }

  console.log(`ğŸ“‹ Found ${candidates.length} compression candidates for user ${userId}`);

  // é‡æ–°è¯„ä¼°é‡è¦æ€§
  const importanceScores = await evaluateImportance(candidates);

  // åˆ†ç±»å¤„ç†
  const toDelete: string[] = [];
  const toCompress: string[] = [];
  const toUpdate: { id: string; score: number }[] = [];

  for (const candidate of candidates) {
    const score = importanceScores.get(candidate.id) || 0.5;

    if (score < 0.2) {
      toDelete.push(candidate.id);
      console.log(`ğŸ—‘ï¸ Will delete (score ${score.toFixed(2)}): "${candidate.content.slice(0, 50)}..."`);
    } else if (score < 0.4) {
      toCompress.push(candidate.id);
      console.log(`ğŸ“¦ Will compress (score ${score.toFixed(2)}): "${candidate.content.slice(0, 50)}..."`);
    } else {
      // æ›´æ–°é‡è¦æ€§è¯„åˆ†ä½†ä¿ç•™
      toUpdate.push({ id: candidate.id, score });
    }
  }

  // æ‰§è¡Œåˆ é™¤
  if (toDelete.length > 0) {
    await supabase.rpc('mark_memories_compressed', {
      p_memory_ids: toDelete,
      p_action: 'delete',
    });
  }

  // æ‰§è¡Œå‹ç¼©ï¼ˆè½¯åˆ é™¤ï¼‰
  if (toCompress.length > 0) {
    await supabase.rpc('mark_memories_compressed', {
      p_memory_ids: toCompress,
      p_action: 'compress',
    });
  }

  // æ›´æ–°ä¿ç•™è®°å¿†çš„é‡è¦æ€§è¯„åˆ†
  for (const { id, score } of toUpdate) {
    await supabase
      .from('user_memories')
      .update({ importance_score: score })
      .eq('id', id);
  }

  return {
    evaluated: candidates.length,
    deleted: toDelete.length,
    compressed: toCompress.length,
  };
}

/**
 * ä¸»å¤„ç†å‡½æ•°
 */
serve(async (req) => {
  // CORS é¢„æ£€
  if (req.method === 'OPTIONS') {
    return new Response('ok', { headers: corsHeaders });
  }

  const startTime = Date.now();

  try {
    // åˆå§‹åŒ– Supabase
    const supabaseUrl = Deno.env.get('SUPABASE_URL')!;
    const supabaseServiceKey = Deno.env.get('SUPABASE_SERVICE_ROLE_KEY')!;
    const supabase = createClient(supabaseUrl, supabaseServiceKey);

    const { action, userId } = await req.json();
    console.log(`ğŸš€ Memory compressor started: action=${action}, userId=${userId || 'all'}`);

    let result: unknown;

    switch (action) {
      case 'compress_all': {
        // è·å–æ‰€æœ‰æœ‰æ´»è·ƒè®°å¿†çš„ç”¨æˆ·
        const { data: users } = await supabase
          .from('user_memories')
          .select('user_id')
          .eq('compression_status', 'active');

        const uniqueUsers = [...new Set(users?.map(u => u.user_id) || [])];
        console.log(`ğŸ‘¥ Processing ${uniqueUsers.length} users`);

        const totals: CompressionResult = {
          evaluated: 0,
          deleted: 0,
          compressed: 0,
          contradictionsResolved: 0,
          mergedGroups: 0,
        };

        for (const uid of uniqueUsers) {
          try {
            const compression = await compressLowValueMemories(supabase, uid);
            const contradictions = await resolveContradictions(supabase, uid);

            totals.evaluated += compression.evaluated;
            totals.deleted += compression.deleted;
            totals.compressed += compression.compressed;
            totals.contradictionsResolved += contradictions;
          } catch (error) {
            console.error(`Error processing user ${uid}:`, error);
          }
        }

        result = {
          success: true,
          usersProcessed: uniqueUsers.length,
          ...totals,
          durationMs: Date.now() - startTime,
        };
        break;
      }

      case 'compress_user': {
        if (!userId) {
          throw new Error('Missing userId for compress_user action');
        }

        const compression = await compressLowValueMemories(supabase, userId);
        const contradictions = await resolveContradictions(supabase, userId);

        result = {
          success: true,
          userId,
          ...compression,
          contradictionsResolved: contradictions,
          durationMs: Date.now() - startTime,
        };
        break;
      }

      case 'dry_run': {
        if (!userId) {
          throw new Error('Missing userId for dry_run action');
        }

        // åªè·å–å€™é€‰ï¼Œä¸æ‰§è¡Œ
        const { data: candidates } = await supabase.rpc('get_compression_candidates', {
          p_user_id: userId,
          p_min_age_days: MIN_AGE_DAYS,
          p_low_importance_threshold: LOW_IMPORTANCE_THRESHOLD,
          p_limit: 50,
        });

        const importanceScores = await evaluateImportance(candidates || []);

        result = {
          success: true,
          userId,
          candidates: (candidates || []).map(c => ({
            ...c,
            evaluatedScore: importanceScores.get(c.id),
            action: importanceScores.get(c.id)! < 0.2 ? 'delete'
              : importanceScores.get(c.id)! < 0.4 ? 'compress'
              : 'keep',
          })),
          durationMs: Date.now() - startTime,
        };
        break;
      }

      default:
        throw new Error(`Unknown action: ${action}`);
    }

    console.log(`âœ… Memory compressor completed in ${Date.now() - startTime}ms`);
    console.log(JSON.stringify(result, null, 2));

    return new Response(
      JSON.stringify(result),
      { headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
    );
  } catch (error) {
    console.error('âŒ Memory compressor error:', error);
    return new Response(
      JSON.stringify({
        success: false,
        error: error.message,
        durationMs: Date.now() - startTime,
      }),
      { status: 500, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
    );
  }
});
```

---

## æ–‡ä»¶å˜æ›´æ¸…å•

| æ“ä½œ | æ–‡ä»¶è·¯å¾„ | è¯´æ˜ |
|------|---------|------|
| **æ–°å»º** | `supabase/migrations/20260127100000_tolan_memory_system.sql` | æ•°æ®åº“è¿ç§» |
| **æ–°å»º** | `supabase/migrations/20260127110000_memory_compression_cron.sql` | Cron é…ç½® |
| **æ–°å»º** | `supabase/functions/memory-compressor/index.ts` | å¤œé—´å‹ç¼©å‡½æ•° |
| **ä¿®æ”¹** | `supabase/functions/get-system-instruction/index.ts` | æ·»åŠ  Multi-Query RAG |
| **ä¿®æ”¹** | `supabase/functions/memory-extractor/index.ts` | æ·»åŠ é‡è¦æ€§è¯„åˆ† |
| **æ›´æ–°** | `docs/architecture/memory-system.md` | æ›´æ–°æ¶æ„æ–‡æ¡£ |

---

*æ–‡æ¡£ç»“æŸ*
