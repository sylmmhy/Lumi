# useAICoachSession 重构计划

> 最后更新：2026-02-05
> 当前状态：1519 行，已完成日志收敛和竞态修复

---

## 现状总结

### 文件概况

`useAICoachSession.ts` 是一个顶层组合 Hook，将 7 大子系统（Gemini Live、虚拟消息、VAD、波形动画、倒计时、记忆保存、篝火模式）组装成统一接口。当前 1519 行，20+ 个 Ref，职责过多导致难以阅读和维护。

### 已完成的前置修复（另一个 AI 做的）

| 修复 | 说明 |
|------|------|
| **日志收敛** | 生产环境的 `console.log` 全部改为 `devLog/devWarn/devError`（仅 DEV 输出），生产环境只保留 `startSession` 和 `saveSessionMemory` 的最小化错误日志 |
| **竞态修复** | 新增 `sessionEpochRef`（cleanup 时 bump，异步操作后检查是否过期）和 `startSessionInFlightRef`（防止并发 startSession） |
| **篝火重连修复** | 重连/退出时先 `disconnect()` 再 `connect()`，避免残留 sessionRef 导致连接被忽略 |

### 关键发现：`useCampfireSession.ts` 不能直接复用

项目中已存在独立的 `src/hooks/campfire/useCampfireSession.ts`（584 行），但**架构不兼容**：

| 维度 | useAICoachSession 内的篝火逻辑 | useCampfireSession |
|------|------|------|
| Gemini 连接 | **共享**主 Hook 的 geminiLive 实例 | 创建**自己的** useGeminiLive 实例 |
| 模式切换 | 从教练模式切入/切出，共享 system prompt | 独立会话，没有教练模式概念 |
| 意图检测 | 集成 useIntentDetection | 无 |
| 虚拟消息 | 篝火模式时禁用虚拟消息 | 无虚拟消息系统 |

**结论**：不能直接用 `useCampfireSession` 替换，但可以把后端 API 调用（`start-campfire-focus`、`update-focus-session`）抽成共享的 service 函数，两边复用。

---

## 不可破坏的边界（Phase 0）

### 对外 API 契约（返回值签名不变）

```typescript
// 以下返回值结构是稳定契约，重构不能改变
return {
  // 状态
  state, isConnecting, isSessionActive, isObserving, connectionError,
  // Gemini Live 状态
  isConnected, isSpeaking, cameraEnabled, videoStream, error,
  // VAD + 波形
  isUserSpeaking, waveformHeights,
  // 操作方法
  startSession, endSession, stopAudioImmediately, resetSession,
  saveSessionMemory, updateTaskId, sendTextMessage, toggleCamera,
  // 虚拟消息调度器
  orchestratorContext, triggerMemoryRetrieval,
  // Refs
  videoRef, canvasRef,
  // 篝火模式
  isCampfireMode, enterCampfireMode, exitCampfireMode, campfireStats,
};
```

### 调用方（重构时不改这些文件）

- `TaskFlowController.tsx`
- `AppTabsPage.tsx`
- `DevTestPage.tsx`
- `HabitOnboardingPage.tsx`

### 回归检查清单

每完成一个 Phase，必须在 `DevTestPage` 上验证：

- [ ] 能正常连上 Gemini（startSession 成功）
- [ ] 能说话、AI 能回复（转录管道正常）
- [ ] 倒计时正常减少，到 0 触发结束回调
- [ ] 结束会话后记忆能保存
- [ ] 篝火模式能进入和退出
- [ ] 篝火模式中 VAD 触发能重连 AI
- [ ] `npm run build` 通过

---

## 目标目录结构

```
src/hooks/ai-coach/
├── index.ts                     # 对外导出（保持 import 路径兼容）
├── useAICoachSession.ts         # 主编排层（~200 行）
├── types.ts                     # 类型定义 + 配置常量（~70 行）
├── utils.ts                     # withTimeout, isValidUserSpeech（~40 行）
├── useTranscriptProcessor.ts    # 语音转录处理 & 消息管理（~120 行）
├── useSessionTimer.ts           # 倒计时逻辑（~100 行）
├── useSessionMemory.ts          # 记忆保存 & 任务时长更新（~200 行）
├── useCampfireMode.ts           # 篝火模式全部逻辑（~300 行）
└── useSessionLifecycle.ts       # startSession/cleanup/endSession（~250 行）
```

预期：主文件从 1519 行降到 ~200 行，每个子模块 100~300 行。

---

## 执行计划

### Phase 1：提取类型和工具函数（零风险）

**目标**：只动文件组织，不动任何行为逻辑。

#### 1.1 创建目录和文件

```
src/hooks/ai-coach/
├── types.ts      # 从主文件提取
├── utils.ts      # 从主文件提取
└── index.ts      # 重新导出
```

#### 1.2 `types.ts` 内容（从主文件第 60~98 行提取）

```typescript
// 配置常量
export const CONNECTION_TIMEOUT_MS = 15000;
export const MAX_CAMERA_RETRIES = 2;
export const CAMERA_RETRY_DELAY_MS = 1000;

// 类型定义
export interface AICoachMessage { ... }
export interface AICoachSessionState { ... }
export interface UseAICoachSessionOptions { ... }
```

#### 1.3 `utils.ts` 内容（从主文件第 40~97 行提取）

```typescript
export function withTimeout<T>(...) { ... }
export function isValidUserSpeech(text: string): boolean { ... }
```

#### 1.4 `index.ts` 保持兼容

```typescript
export { useAICoachSession } from './useAICoachSession';
export type { AICoachMessage, AICoachSessionState, UseAICoachSessionOptions } from './types';
```

#### 1.5 迁移路径

- 将原 `src/hooks/useAICoachSession.ts` 移到 `src/hooks/ai-coach/useAICoachSession.ts`
- 原路径放一个 re-export 文件，保持调用方不用改 import

**预计减少主文件**：~70 行
**验证**：`npm run build` 通过

---

### Phase 2：提取篝火模式（减少最多行数）

**目标**：将篝火模式的 ~300 行代码提取为独立 Hook。

#### 2.1 `useCampfireMode.ts` 接口设计

```typescript
interface UseCampfireModeOptions {
  // 来自主 Hook 的 geminiLive 实例（共享连接）
  geminiLive: ReturnType<typeof useGeminiLive>;
  // 篝火模式需要的上下文
  savedSystemInstruction: string;
  currentUserId: string | null;
  currentTaskDescription: string;
  preferredLanguage: string;
  // 竞态控制
  sessionEpoch: React.MutableRefObject<number>;
  // 状态通知
  isSessionActive: boolean;
}

interface UseCampfireModeReturn {
  // 状态
  isCampfireMode: boolean;
  campfireStats: { ... };
  // 操作
  enterCampfireMode: (options?: { skipFarewell?: boolean }) => Promise<void>;
  exitCampfireMode: () => Promise<CampfireStats | null>;
  stopCampfireResources: () => void;
}
```

#### 2.2 包含的代码（从主文件提取）

- 篝火状态：`isCampfireMode`, `campfireSessionId`, `campfireChatCount`（第 124~127 行）
- 篝火 Refs：`campfireReconnectLockRef`, `campfireIdleTimerRef`, `campfireMicStreamRef`（第 134~138 行）
- 子 Hooks：`useAmbientAudio`, `useFocusTimer`（第 300~303 行）
- 意图检测：`useIntentDetection` + ref 同步（第 306~322 行）
- 篝火核心函数：`clearCampfireIdleTimer`, `startCampfireIdleTimer`, `callStartCampfireFocus`, `campfireReconnectGemini`, `enterCampfireMode`, `exitCampfireMode`, `stopCampfireResources`（第 604~905 行）
- 篝火 VAD + effects（第 855~890 行）
- ref 同步 effect（第 845~849 行）

#### 2.3 不搬走的部分

- `useIntentDetection` 的 `intentDetectionRef` 同步 → 留在主 Hook（因为 onTranscriptUpdate 需要调用它）
- 但 `onDetectionComplete` 回调可以从 `useCampfireMode` 暴露

**预计减少主文件**：~300 行
**验证**：回归检查清单中的篝火模式项

---

### Phase 3：提取倒计时（自洽性最强）

**目标**：将倒计时的定时器逻辑和 Ref 同步内聚到一个 Hook 里。

#### 3.1 `useSessionTimer.ts` 接口设计

```typescript
interface UseSessionTimerOptions {
  initialTime: number;
  onTimerComplete: () => void;  // 倒计时归零时调用
}

interface UseSessionTimerReturn {
  timeRemaining: number;
  isTimerRunning: boolean;
  taskStartTime: number;
  startTimer: () => void;
  stopTimer: () => void;
  resetTimer: () => void;
}
```

#### 3.2 包含的代码

- `startCountdown`, `stopCountdown`（第 469~480 行）
- `timerRef`, `taskStartTime` state（第 120, 129 行）
- 倒计时 effect（第 558~599 行）
- `cleanupRef`, `saveSessionMemoryRef`, `onCountdownCompleteRef` 的同步逻辑

#### 3.3 关键设计决策

**Ref 同步逻辑内聚**：目前主文件里有 3 个 "用 ref 存最新函数引用" 的 effect（`cleanupRef`, `saveSessionMemoryRef`, `onCountdownCompleteRef`），都是为了让 `setInterval` 回调拿到最新闭包。拆成子 Hook 后，`onTimerComplete` 作为参数传入，子 Hook 内部自己管 ref 同步，主文件不再需要这些 effect。

**预计减少主文件**：~100 行（含 ref 同步 effect）
**验证**：倒计时正常 + 归零时触发保存和结束

---

### Phase 4：提取记忆保存

**目标**：将 `saveSessionMemory` 及其辅助逻辑提取为独立 Hook。

#### 4.1 `useSessionMemory.ts` 接口设计

```typescript
interface UseSessionMemoryOptions {
  initialTime: number;
}

interface UseSessionMemoryReturn {
  saveSessionMemory: (options?: {
    additionalContext?: string;
    forceTaskCompleted?: boolean;
  }) => Promise<boolean>;
  // 供外部 ref 同步用
  saveSessionMemoryRef: React.MutableRefObject<typeof saveSessionMemory>;
}
```

#### 4.2 包含的代码

- `saveSessionMemory` 函数（第 1247~1410 行）
- `saveSessionMemoryRef` 及其同步 effect（第 1412~1417 行）
- 依赖的 Refs：`currentUserIdRef`, `currentTaskDescriptionRef`, `currentTaskIdRef`, `userSpeechBufferRef`

#### 4.3 设计注意点

这个 Hook 需要访问 `state.messages` 和 `state.timeRemaining`。两种方案：

- **方案 A（推荐）**：`saveSessionMemory` 接受参数而非读 state，由主 Hook 调用时传入
- **方案 B**：将 messages 和 timeRemaining 作为 Hook 参数传入

选方案 A 的原因：让 `useSessionMemory` 成为纯函数式的工具，不依赖外部 state，更容易测试。

**预计减少主文件**：~180 行
**验证**：会话结束后记忆正常保存

---

### Phase 5：提取转录处理

**目标**：将 `onTranscriptUpdate` 回调及相关的 buffer/去重逻辑提取出来。

#### 5.1 `useTranscriptProcessor.ts` 接口设计

```typescript
interface UseTranscriptProcessorOptions {
  onUserMessage: (text: string) => void;    // 完整用户消息（buffer 刷新后）
  onAIMessage: (text: string) => void;      // AI 消息
  onUserSpeechFragment: (text: string) => void;  // 用户语音碎片（给意图检测用）
}

interface UseTranscriptProcessorReturn {
  /** 传给 useGeminiLive 的 onTranscriptUpdate 回调 */
  handleTranscriptUpdate: (transcript: TranscriptEntry[]) => void;
  /** 添加消息到列表（也给虚拟消息系统用） */
  addMessage: (role: 'user' | 'ai', content: string, isVirtual?: boolean) => void;
  /** ref 版本（给闭包场景用） */
  addMessageRef: React.MutableRefObject<typeof addMessage>;
  /** 消息列表 */
  messages: AICoachMessage[];
  /** 清空 buffer 并返回剩余内容（给记忆保存用） */
  flushUserSpeechBuffer: () => string;
  /** 重置所有状态 */
  reset: () => void;
}
```

#### 5.2 包含的代码

- `addMessage` 函数 + ref 同步（第 198~220 行）
- `onTranscriptUpdate` 回调（第 230~293 行）
- `processedTranscriptRef`, `userSpeechBufferRef`, `lastProcessedRoleRef`（第 136~162 行）
- `aiSpeechLogBufferRef`, `aiSpeechLogTimerRef`（第 171~172 行）

#### 5.3 关键设计

回调中需要调用 `orchestratorRef` 和 `intentDetectionRef`，但这些是外部系统。通过 `onUserMessage` / `onAIMessage` / `onUserSpeechFragment` 回调抽象，让 `useTranscriptProcessor` 不知道具体的下游消费者。

**预计减少主文件**：~120 行
**验证**：说话和 AI 回复正常，消息列表正确

---

### Phase 6：提取会话生命周期

**目标**：将 `startSession` 的硬件初始化 + 连接逻辑提取出来。

#### 6.1 `useSessionLifecycle.ts` 接口设计

```typescript
interface UseSessionLifecycleOptions {
  geminiLive: ReturnType<typeof useGeminiLive>;
  initialTime: number;
  sessionEpochRef: React.MutableRefObject<number>;
  onSessionReady: (systemInstruction: string, successRecord: SuccessRecordForVM | null) => void;
  onSessionError: (error: Error) => void;
}

interface UseSessionLifecycleReturn {
  startSession: (taskDescription: string, options?: StartSessionOptions) => Promise<boolean>;
  cleanup: () => void;
  endSession: () => void;
  resetSession: () => void;
  stopAudioImmediately: () => void;
  // 状态
  isConnecting: boolean;
  isSessionActive: boolean;
  isObserving: boolean;
  connectionError: string | null;
}
```

#### 6.2 包含的代码

- `startSession` 函数（第 922~1210 行，最大的函数）
- `cleanup` 函数（第 485~547 行）
- `endSession`, `resetSession`, `stopAudioImmediately`（第 1218~1435 行）
- 连接状态：`isConnecting`, `isSessionActive`, `isObserving`, `connectionError`
- 竞态保护：`sessionEpochRef`, `startSessionInFlightRef`, `isCleaningUpRef`
- 通话记录逻辑：`currentCallRecordIdRef`

#### 6.3 这是改动最大的一步

`startSession` 本身 ~280 行，包含硬件初始化（摄像头重试、麦克风）、网络请求（system instruction、token）、Gemini 连接。这一步最后做是因为：
- 它和主 Hook 的耦合最紧（需要访问很多 ref 和 state）
- 前面的 Phase 已经把其他模块拆走了，剩下的主文件已经足够小，这一步的 diff 也更清晰

**预计减少主文件**：~250 行
**验证**：完整的连接 → 对话 → 结束流程

---

### Phase 7（可选，改动较大）：统一 Gemini Live 实现

**背景**：项目中存在两套 Gemini Live 实现：
- 旧版：`src/hooks/useGeminiLive.ts`
- 新版模块化：`src/hooks/gemini-live/`（含 core、media、features 分层）

**建议**：等 Phase 1~6 完成后再评估。如果后续需要对 Gemini 连接层做改动，优先在模块化版本上迭代，再逐步迁移调用方。

---

## 预期结果

### 行数分布（拆分后）

| 文件 | 预计行数 | 职责 |
|------|---------|------|
| `useAICoachSession.ts` | ~200 | 编排层：组合子 Hook，桥接数据流 |
| `types.ts` | ~70 | 类型定义 + 配置常量 |
| `utils.ts` | ~40 | 工具函数 |
| `useTranscriptProcessor.ts` | ~120 | 语音转录 → 消息 |
| `useSessionTimer.ts` | ~100 | 倒计时 |
| `useSessionMemory.ts` | ~200 | 记忆保存 |
| `useCampfireMode.ts` | ~300 | 篝火模式 |
| `useSessionLifecycle.ts` | ~250 | 会话启动/结束 |
| **合计** | ~1280 | 略少于原来（消除了一些重复的 ref 同步） |

### 主要收益

1. **可读性**：每个文件有单一职责，命名即文档
2. **可维护性**：改篝火模式不需要翻 1500 行找代码
3. **Ref 减少**：子 Hook 内部管理自己的 Ref，主 Hook 不再需要大量 ref 同步 effect
4. **可测试性**：子 Hook 可以独立单测（尤其 `useSessionTimer`、`useSessionMemory`）
5. **向后兼容**：对外 API 完全不变，调用方零改动

---

## 风险和注意事项

### 1. Hooks 调用顺序

React 要求 Hooks 不能在条件语句中调用。拆成子 Hook 后，所有子 Hook 必须在主 Hook 的顶层无条件调用，通过参数（如 `enabled`）控制是否激活。

### 2. 闭包和 Ref 传递

子 Hook 之间通过参数和回调通信时，需要注意闭包捕获问题。原则：
- 子 Hook 暴露的函数如果会被异步调用（如 setTimeout、effect），应该用 `useCallback` 包裹
- 如果主 Hook 传给子 Hook 的回调会变化，子 Hook 内部应该用 ref 存储

### 3. 状态提升 vs 下沉

有些状态（如 `messages`）被多个子系统使用。原则：
- 如果只有一个子 Hook 读写 → 放到子 Hook 内部
- 如果多个子 Hook 都需要 → 保留在主 Hook，通过参数传递

### 4. 循环依赖

目前的 ref 模式（`orchestratorRef`、`intentDetectionRef`）本质上是为了解决"A 的回调需要调用 B，但 B 的 Hook 还没定义"的问题。拆分后，通过主 Hook 作为中间人传递回调，可以消除大部分 ref 同步。
