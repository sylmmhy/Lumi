它不是“组件”，而是一个顶层组合 Hook：把一堆子系统（Gemini Live、虚拟消息、VAD、倒计时、记忆保存、篝火模式等）接线到一起，所以会显得又大又杂。

1. 分门别类：它到底做了哪些事
A. 对外接口（你在页面/组件里能用什么）
它接收 UseAICoachSessionOptions：

initialTime：默认 300 秒
onCountdownComplete
enableVirtualMessages
enableVAD
它返回的核心能力：

会话状态：state.taskDescription / state.timeRemaining / state.isTimerRunning / state.messages
连接状态：isConnecting / isSessionActive / isObserving / connectionError
Gemini 状态：isConnected / isSpeaking / cameraEnabled / videoStream / error 等（来自 useGeminiLive）
UI 用的数据：waveformHeights、videoRef、canvasRef
操作方法：startSession / endSession / resetSession / stopAudioImmediately / saveSessionMemory / sendTextMessage / toggleCamera / updateTaskId
篝火模式：isCampfireMode / enterCampfireMode / exitCampfireMode / campfireStats
调用方主要在这些文件里（重构时需要“尽量不改它们”）：

TaskFlowController.tsx
AppTabsPage.tsx
DevTestPage.tsx
HabitOnboardingPage.tsx
B. 会话生命周期（开始、结束、清理、重置）
startSession（最重的一块）主要做：

初始化/重置各种 ref（用户 id、任务描述、taskId、callRecordId、去重集合、buffer 等）
如果发现旧连接还在：先走统一 cleanup() 清掉旧会话
并行做 4 件事（用 Promise.all + withTimeout）：
摄像头启用（带重试）
麦克风启用（并在成功后调用后端记录 mic_connected_at）
调用后端 Edge Function：get-system-instruction（做“记忆检索 + system prompt 生成”，还会返回 successRecord）
fetchGeminiToken()
连接 Gemini：geminiLive.connect(systemInstruction, ..., token, voiceName)
标记会话 active、进入“观察阶段”（isObserving=true）、启动倒计时
开场白不在这里发，而是交给 useVirtualMessages 统一处理
cleanup（统一清理）负责：

停止倒计时
geminiLive.disconnect()
重置会话标志位
如果有 callRecordId：调用 manage-call-records 记录通话结束和时长
endSession / resetSession / stopAudioImmediately：

endSession()：本质就是调用 cleanup()
resetSession()：endSession() + 清 refs + 重置 state
stopAudioImmediately()：只立刻停音频（不断开连接），用于“用户挂断要立刻静音，但后台还要保存记忆”等场景
C. 转录与消息管道（Gemini transcript -> UI messages）
useGeminiLive({ onTranscriptUpdate }) 是整个“对话输入输出”的入口。

核心逻辑：

用 processedTranscriptRef 给 transcript 做去重（避免重复处理同一条）
用户语音不是马上落库/入 messages：
先累积在 userSpeechBufferRef
等 AI 开始说话（assistant transcript 出现）之前，把 buffer 拼成一句完整“用户说的话”，再 addMessage('user', ...)
这样做的目的：避免每个词/碎片都变成一条消息，后面“话题检测/记忆检索/意图检测”也能拿到更完整的句子
AI 的 transcript 会直接 addMessage('ai', ...)
同时把用户/AI 内容喂给两个系统：
useVirtualMessageOrchestrator：做上下文追踪、记忆注入窗口等
useIntentDetection：检测是否触发 enter/exit campfire
D. 虚拟消息：实际上有“两套系统”同时存在
新的：useVirtualMessageOrchestrator（注释里叫“方案 2：过渡话注入”）
用于对话上下文追踪、在 turnComplete 后尝试静默注入记忆等
旧的：useVirtualMessages（“定时触发系统”）
会在合适时机触发开场白/提醒
同时支持“智能小纸条”：会调用后端 generate-coach-guidance
另外它还把 Gemini 的 turnComplete 同时通知给：

virtualMessages（用于冷却期）
orchestrator（用于安全窗口期注入）
E. 倒计时（与“保存记忆 + 清理”绑定）
倒计时每秒减 state.timeRemaining。
当减到 0：

saveSessionMemoryRef.current() 保存记忆
cleanupRef.current() 清理
onCountdownCompleteRef.current?.() 回调
这里大量使用 useRef + useEffect 同步 ref 的原因很朴素：

interval 回调如果直接引用函数/状态，很容易拿到旧闭包（React Hook 常见坑）
所以作者用 ref 保证“倒计时结束时调用的是最新版本的 save/cleanup/callback”
F. 记忆保存（前端把对话发给后端 memory-extractor）
saveSessionMemory()做的事：

校验 userId
把 userSpeechBufferRef 里剩余没 flush 的用户话补进 messages
过滤掉虚拟消息（只保存真实对话）
转成 Mem0 需要的格式（assistant/user/system）
计算任务是否完成、实际时长 actualDurationMinutes
调用 Edge Function memory-extractor（metadata 里带 task_completed 等）
如果任务完成且有 taskId：调用 /remindMe/services/reminderService 的 updateReminder() 把时长写回数据库
G. 篝火模式（Campfire Mode）是一整套“断开/重连策略 + 白噪音 + 专注计时”
它在同一个 hook 里实现了“从 AI 教练切到篝火模式，再切回来”。

进入篝火模式 enterCampfireMode()：

先处理告别语（按钮触发会发 [CAMPFIRE_FAREWELL]，意图检测触发可跳过）
断开 Gemini
单独 getUserMedia({audio:true}) 拿麦克风流，用于“Gemini 断开时仍能 VAD”
开白噪音（useAmbientAudio）+ 启动专注计时（useFocusTimer）
异步调用后端 start-campfire-focus 建立 focus session
篝火模式中：

本地 VAD 触发说话时，调用 start-campfire-focus(true) 拿到 systemPrompt，然后重连 Gemini
空闲 30s 自动断开 Gemini（节省配额）
AI 说话时 duck 白噪音
退出篝火模式 exitCampfireMode()：

停白噪音、停计时、停麦克风流、清 idle timer
用保存的原 coach system prompt 重新 connect 回 AI 教练
调用 update-focus-session 把专注统计回写后端
备注：前端里其实已经有单独的篝火 hook：

useCampfireSession.ts
这意味着后续重构时有机会复用，减少重复逻辑。
2. 前端 log 会打印什么（来自这个 hook）
我按“是否仅 DEV”分组（因为这里同时存在两种）。

A. 生产环境也会打印（没有 import.meta.env.DEV 包起来）
会话启动（非常多，尤其摄像头/麦克风初始化过程）：

🚀 全并行启动: 硬件初始化 + 网络请求同时进行...
🎬 [并行] 摄像头初始化...、📹 摄像头尝试 #...、✅ 摄像头启用成功
摄像头失败相关：❌ 摄像头启用异常:、❌ 摄像头错误详情:、⚠️ 摄像头启用失败...重试...、🔄 重试等待结束...、📹 摄像头初始化循环结束: ...
🎤 [并行] 麦克风初始化...、🎤 调用 toggleMicrophone()...、🎤 toggleMicrophone() 完成、🎤 麦克风已启用，跳过
callRecordId 相关：📞 记录 mic_connected_at:、⚠️ 记录 mic_connected_at 失败:、✅ mic_connected_at 已记录
startSession 异常：❌ startSession 错误:
“智能小纸条”请求失败：

⚠️ generate-coach-guidance 调用失败:
统一清理（和通话记录）：

📞 记录通话结束:（带 { callRecordId, durationSeconds }）
⚠️ 记录通话结束失败:、✅ 通话结束已记录
篝火模式：

🏕️ Entering campfire mode...
🕐 [Campfire] Idle timeout, disconnecting Gemini...
🔌 [Campfire] VAD triggered, reconnecting Gemini...
❌ [Campfire] start-campfire-focus error:
❌ [Campfire] No system prompt from backend
❌ [Campfire] Reconnect failed:
⚠️ [Campfire] Failed to get mic stream for VAD:
🏕️ Exiting campfire mode...
❌ [Campfire] Failed to reconnect AI coach:
Failed to update focus session:
保存记忆/写回数据库失败（即使非 DEV 也会打）：

⚠️ 保存任务完成时长失败:
❌ 保存会话记忆失败:
B. 仅开发环境会打印（import.meta.env.DEV）
转录与对话：

🎤 用户说:（flush 后的整句用户话）
🤖 AI 说:（把流式碎片拼成完整句子后输出）
话题检测失败:
会话启动：

🚀 开始 AI 教练会话...
⚠️ 检测到旧会话，先清理...
✅ 并行获取完成，正在连接 Gemini Live...
🎤 使用 AI 声音:
✅ 连接已建立
✨ AI 教练会话已成功开始
记忆检索（get-system-instruction 返回的 retrievedMemories）：

一段分隔线 + 🧠 [记忆检索] 本次会话取到的记忆: + 逐条打印记忆（或打印“无记忆”）
📊 获取到用户成功记录: ...
观察阶段：

👀 AI 开始说话，观察阶段结束
清理/结束/静音：

🧹 执行统一清理...、✅ 统一清理完成
🔇 立即停止音频播放...
🔌 结束 AI 教练会话...、✅ AI 教练会话已结束
保存记忆（会输出非常详细的 payload/统计/提取结果）：

🧠 正在保存会话记忆...
📤 [Mem0] 发送到 Mem0 的内容: { ...messages }
📊 任务完成状态: { ... }
分隔线 + 💾 [记忆保存] 本次会话存的记忆: + 逐条打印保存的记忆（或“无新记忆”）+ 📊 保存统计:
✅ 任务完成时长已保存到数据库: ...
以及一些提前返回的提示：缺 userId、没消息、全是虚拟消息等
3. 重构计划（尽量不改功能，只把“杂”拆开）
目标：外部 API 不变（调用方不用动），内部按职责拆文件，让每块更容易读、也更容易单独改。

Phase 0：先定“不可破坏的边界”
明确 useAICoachSession 的对外返回结构是稳定契约（上面那堆返回值）。
以 DevTestPage.tsx 作为手工回归入口：每拆一块就跑一遍“能连上、能说话、倒计时结束能保存、能进出篝火”。
Phase 1：先拆“纯工具/类型”（最安全，几乎 0 风险）
把 withTimeout、常量、isValidUserSpeech 抽到独立文件（例如新建目录 src/hooks/ai-coach-session/）。
把 types 抽走：AICoachMessage、AICoachSessionState、UseAICoachSessionOptions 单独放 types.ts。
为什么先做这个：这一步不动行为，只动文件组织，马上让主文件变短。
Phase 2：把“大块业务”按职责变成子 hook（仍保持外部 API 不变）
优先顺序建议：

记忆保存整块抽出去：useSessionMemoryPersistence(...)
为什么：saveSessionMemory() 本身就很“自洽”，依赖明确（userId/task/messages/timeRemaining/initialTime/updateReminder/supabase）。
篝火模式抽出去：useAICoachCampfireMode(...)
为什么：篝火模式有自己的一堆 state/ref/effect，抽掉后主文件会立刻清爽一半。
加分项：评估是否能直接复用 useCampfireSession.ts，至少把调用后端 start-campfire-focus/update-focus-session 的重复逻辑合并掉。
倒计时抽出去：useSessionCountdown(...)
为什么：现在为了避免旧闭包，散落了很多 xxxRef.current 同步逻辑；抽成一个 hook 可以把“为什么要用 ref”集中讲清楚。
Transcript 处理抽出去：createTranscriptHandler(...) 或 useTranscriptMessagePipe(...)
为什么：这块是“消息进入系统的入口”，抽出去后 useAICoachSession 就更像“总控台”。
Phase 3：统一日志（降低噪音，减少 DEV 判断散落）
直接复用现成工具：utils.ts 里的 devLog/devWarn/devError。
把当前大量无条件 console.log（尤其硬件初始化那堆）收敛成 DEV-only，避免生产刷屏和泄露诊断细节。
为什么：你现在觉得“杂乱”，日志是主要噪音源之一，把日志策略收敛后，代码可读性会明显上升。
Phase 4（可选，改动更大）：收敛到统一的 Gemini Live 模块
目前同仓库里存在两套 Gemini Live：

旧：useGeminiLive.ts
新模块化：/Users/miko_mac_mini/projects/Lumi-hackathon/Lumi-front-end/src/hooks/gemini-live/
如果你接下来还要持续演进这套系统，最终建议把 useAICoachSession 迁移到模块化版本（它自带 utils、分层更清楚），但这一步我建议放到前面拆分完成之后再做。